[{"categories":["Workspace"],"content":"如题. ","date":"2021-02-24","objectID":"/posts/ida_skins/:0:0","tags":["CTF","Reverse","Workspace"],"title":"IDA 两个极简主义皮肤","uri":"/posts/ida_skins/"},{"categories":["Workspace"],"content":"仓库地址 Reverier-Xu/IDA-Skins 先放成品. ","date":"2021-02-24","objectID":"/posts/ida_skins/:1:0","tags":["CTF","Reverse","Workspace"],"title":"IDA 两个极简主义皮肤","uri":"/posts/ida_skins/"},{"categories":["Workspace"],"content":"简介 IDA的前端是用Qt撸出来的, 所以老早就感觉可以自定义了. 在7.3之前就有用来自定义皮肤的插件, 用的还是QSS, 7.3之后官方也支持了, 于是抽了点时间出来整了两份样式表, 一黑一白. 大体上的设计是照着VSCode的样式抄下来的, 一股浓浓的微软风. 删掉了几乎所有的渐变色, 用纯色来代替. 导航条换成了灰度色, 不过我平时都没看过, 就当是个全局滚动条了. ","date":"2021-02-24","objectID":"/posts/ida_skins/:2:0","tags":["CTF","Reverse","Workspace"],"title":"IDA 两个极简主义皮肤","uri":"/posts/ida_skins/"},{"categories":["Workspace"],"content":"如何使用 把仓库里那俩文件夹甩到IDA安装目录/themes/下面, 然后打开IDA, Options-\u003eColors, 选择主题即可. 因为我在Linux下使用Wine运行IDA的, 所以字体默认用的是宋体. 虽然渲染没啥问题但看着总感觉难受, 于是就直接在主题里启用了全局JetBrains Mono字体. 如果你的电脑上有JB家的IDE, 那应该已经安装了这个字体, 如果没有的话去JetBrains Mono: 免费开源的代码字体上下载一份装上就行. ","date":"2021-02-24","objectID":"/posts/ida_skins/:3:0","tags":["CTF","Reverse","Workspace"],"title":"IDA 两个极简主义皮肤","uri":"/posts/ida_skins/"},{"categories":["Workspace"],"content":"后续调整 那个工具条我怎么看怎么难受. 调整也调的四不像, 后来想想其实我大部分时间都在用右键菜单和键盘快捷键, 那几个工具条我几乎都没用过, 于是就全部删掉了. 然后瞅了一眼Desktop的布局, 萌生了一个想法: 干脆把VSCode抄到底(?) 于是把布局改成了这样: 嗯, 虽然感觉还是丑了点, 但是比原版看起来舒服多了. 愉快.jpg ","date":"2021-02-24","objectID":"/posts/ida_skins/:4:0","tags":["CTF","Reverse","Workspace"],"title":"IDA 两个极简主义皮肤","uri":"/posts/ida_skins/"},{"categories":["CTF"],"content":"首先下载题目文件，使用binwalk解压出固件内的文件 [Rx][•ᴗ•] \u003e\u003e\u003e binwalk -e ./51475f91-7b90-41dd-81a3-8b82df4f29d0.bin DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 TP-Link firmware header, firmware version: 1.-20432.3, image version: \"\", product ID: 0x0, product version: 155254791, kernel load address: 0x0, kernel entry point: 0x80002000, kernel offset: 4063744, kernel length: 512, rootfs offset: 772784, rootfs length: 1048576, bootloader offset: 2883584, bootloader length: 0 69424 0x10F30 Certificate in DER format (x509 v3), header length: 4, sequence length: 64 94080 0x16F80 U-Boot version string, \"U-Boot 1.1.4 (Aug 26 2013 - 09:07:51)\" 94256 0x17030 CRC32 polynomial table, big endian 131584 0x20200 TP-Link firmware header, firmware version: 0.0.3, image version: \"\", product ID: 0x0, product version: 155254791, kernel load address: 0x0, kernel entry point: 0x80002000, kernel offset: 3932160, kernel length: 512, rootfs offset: 772784, rootfs length: 1048576, bootloader offset: 2883584, bootloader length: 0 132096 0x20400 LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 2203728 bytes 1180160 0x120200 Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 2774624 bytes, 519 inodes, blocksize: 131072 bytes, created: 2015-04-13 09:35:04 在解压出来的文件中包含了kernel镜像以及一个squashfs文件系统镜像。 使用firmware-mod-kit工具包内的unsquashfs_all.sh解压文件系统镜像，这个包在仓库blackarch中，直接安装包名即可。unsquashfs_all.sh的位置在/usr/share/firmware-mod-kit/unsquashfs_all.sh [Rx][•ᴗ•] \u003e\u003e\u003e /usr/share/firmware-mod-kit/unsquashfs_all.sh ./120200.squashfs Exception ignored in: \u003c_io.TextIOWrapper name='\u003cstdout\u003e' mode='w' encoding='utf-8'\u003e BrokenPipeError: [Errno 32] Broken pipe Attempting to extract SquashFS 4.X file system... Skipping squashfs-2.1-r2 (wrong version)... Skipping squashfs-3.0 (wrong version)... Skipping squashfs-3.0-lzma-damn-small-variant (wrong version)... Skipping others/squashfs-2.0-nb4 (wrong version)... Skipping others/squashfs-2.2-r2-7z (wrong version)... Skipping others/squashfs-3.0-e2100 (wrong version)... Skipping others/squashfs-3.2-r2 (wrong version)... Skipping others/squashfs-3.2-r2-lzma (wrong version)... Skipping others/squashfs-3.2-r2-lzma/squashfs3.2-r2/squashfs-tools (wrong version)... Skipping others/squashfs-3.2-r2-hg612-lzma (wrong version)... Skipping others/squashfs-3.2-r2-wnr1000 (wrong version)... Skipping others/squashfs-3.2-r2-rtn12 (wrong version)... Skipping others/squashfs-3.3 (wrong version)... Skipping others/squashfs-3.3-lzma/squashfs3.3/squashfs-tools (wrong version)... Skipping others/squashfs-3.3-grml-lzma/squashfs3.3/squashfs-tools (wrong version)... Skipping others/squashfs-3.4-cisco (wrong version)... Skipping others/squashfs-3.4-nb4 (wrong version)... Trying ./src/others/squashfs-4.2-official/unsquashfs... Parallel unsquashfs: Using 12 processors Trying ./src/others/squashfs-4.2/unsquashfs... Parallel unsquashfs: Using 12 processors Trying ./src/others/squashfs-4.0-lzma/unsquashfs-lzma... Parallel unsquashfs: Using 12 processors 480 inodes (523 blocks) to write [=======================================================================| ] 454/523 86% created 341 files created 39 directories created 70 symlinks created 0 devices created 0 fifos File system sucessfully extracted! MKFS=\"./src/others/squashfs-4.0-lzma/mksquashfs-lzma\" 解压出来的文件夹中tmp目录下有一个叫做backdoor的后门二进制文件，查壳发现被upx压缩过，upx -d解压之，然后拖进IDA 成了。 ","date":"2021-01-12","objectID":"/posts/buuctf_firmware/:0:0","tags":["CTF","Reverse"],"title":"BUUCTF firmware WriteUp","uri":"/posts/buuctf_firmware/"},{"categories":["CTF"],"content":"如题. 使用IDA打开题目文件后, 发现没有识别出main函数, 可以初步判断是由于花指令造成的. 在左侧的函数列表里发现了mprotect函数, 这个函数是用来更改内存读写权限的, 隐约感觉有smc(Self-Modifying Code)的存在. 先从start函数定位到main函数所在的区段, 发现了明显的花指令特征: 试图用GDB调试到此位置: 于是在IDA里将光标定位至0x400BB1的位置, 按下U键取消定义, 然后在0x400BB2的位置按下C键Make Code, 然后再用IDAPython给0x400BB1变成nop PatchByte(0x400BB1, 0x90) 继续往下分析, 0x400BBC处还有几个神必数据莫得头绪. 不过从BB7跳转到了BBF, 所以继续往下看, 然后… 它retn了. 继续用gdb断点到0x400BB7, 然后接着调试: 可以看到程序控制流从0x400BD0跳到了0x400BBD, 接着跳转到了0x400BD1. 由此可以推测出0x400BBC处也是一个花指令. 先在0x400BBD的位置变成汇编, 再用相同的办法把BBC给nop掉: 由此可以看出来, 从0x400BB7到0x400BD0的一大段代码实际上全是无效代码. 用IDAPython写个循环全部变成nop就完事了: 在0x400CBA处还有一个长得一模一样的东西, 同样处理之, 0x400D04还有一坨, nop掉即可. 全部搞定之后把光标移到最上面的main处, 戳一下F5, 代码就反编译成功了: 第20行弄了个函数指针, 21行用mprotect函数将某个text段的读写执行权限改成了7, 也就是b111, 即可读可写可执行. 22~23行通过函数指针, 将该函数的前十个字节与v4的前五位异或, 然后第24行用刚刚修改过的函数对输入进行验证. 对部分变量重命名一下, 好康点. 可以发现是用了flag的前五位. 这个比赛的所有flag格式均为n1ctf{xxx}, 那么前五位必然是n1ctf. 定位到evaluate函数所在的位置, 用IDAPython把正确代码处理回来, 否则没法F5. 好极了, 代码恢复成功, F5试一下…失败了, 往下面一看, 还是有花指令. 想试着调试一下, 结果发现了 第17行那个函数, 里面调用了ptrace对程序的运行状态进行了监视. 而gdb也是通过ptrace进行调试的, 同一时间只能有一个调试器挂在程序上, 所以起到了反调试的作用. 不过往下看, read函数是在反调函数下面的, 所以可以先运行程序, 跑起来之后等待输入时用gdb再attach上去. 接下来定位到0x400ABC, 然后跟踪一下函数流程, 并把花指令都给处理掉. 有如下几个地方: for i in range(0x400AC4, 0x400AC9): PatchByte(i, 0x90) for i in range(0x400B0E, 0x400B28): PatchByte(i, 0x90) 搞完了之后再F5一下, evaluate函数的真容就浮现出来了. 因为smc和花指令的影响, 之前main函数中给evaluate传的参数乱七八糟, 重新F5一下main函数, 找到这几行: 然后再看重命名之后的evaluate函数: 你可以右键参数, 然后选择set lvar type, 改成指针之后就能显示出来数组形式的表达式了. 第39行处理的地址是\u0026v20+1-32, 看一下上面的变量声明, 这个地方就是v5, 那么这个循环就是遍历了v5~v18. 还有个难题就是space里面存的到底是个什么东西了. 答案其实很简单, 我们点进那个反调试函数里面瞅一眼, 发现他运行了一下/usr/bin/cat /proc/version, 动态调试到evaluate里面, 输出一下栈里面的东西, 发现space存的实际上就是/usr/bin/cat /proc/version指令的输出, 即你的linux版本信息, 然后取前13位. 因为是linux程序, 所以不管在什么系统上, 前13位必然是Linux Version , 那就保证唯一性了. 接下来就是快乐的拿flag时间了. 脚本: #!/bin/python3 # from __future__ import print_function magic = [53, 45, 17, 26, 73, 125, 17, 20, 43, 59, 62, 61, 60, 95] space = 'Linux Version ' head = 'n1ctf' print (head,end='') for i in range(len(magic)): print(chr(magic[i] ^ (ord(space[i]) + 2)), end='') flag: n1ctf{Fam3_Is_NULL} ","date":"2020-10-26","objectID":"/posts/n1ctf_oflo/:0:0","tags":["CTF"],"title":"N1CTF-oflo WriteUp","uri":"/posts/n1ctf_oflo/"},{"categories":["Memo"],"content":"如题 ","date":"2020-09-21","objectID":"/posts/mssctf_2020_memos/:0:0","tags":["CTF","Memo"],"title":"MssCTF 2020 赛后总结","uri":"/posts/mssctf_2020_memos/"},{"categories":["Memo"],"content":"运维与反作弊 在讨论平台的反作弊措施时有人提出了能否给不同选手分发不同题目文件的想法, 思索了一下觉得可行, 我便答应下来, 然后投入到静态题目文件自动分发插件的工作当中. 由于时间紧急就没能好好研究CTFd的文件上传与储存机制, 最开始的想法是创建一种新的挑战类型, 然后慢慢改; 后来写好之后发现数据库冲突了, 测试了好久依旧无法实现. 经Frank的提示, 发现其实只要创建一种新的flag类型即可. 时间紧急就采用了最简单的写法, 在api/v1/challenges.py里直接判断flag类型然后返回对应的文件, 简单粗暴. 这样写出来的插件由于更改了平台原有的文件, 所以没法即插即用, 等有时间了好好研究一下如何在不更改原有api的情况下实现自动分发. 初赛太辛苦BlackW@tch了. 初赛Web题目采用了静态docker部署的方式, 所有选手共用一个环境. 赛前去看他部署的时候发现apache的日志输出直接映射到了stdout, 这样搞的没办法查看log了, 但是想着题目应该不会出啥大问题, 折腾了一会儿没折腾好就放弃了. 第二天就直接上线. 然后web题成功出问题了. 有一名选手拿到flag之后挂了个脚本持续删掉flag, 重启docker之后继续删, 活生生的把CTF变成了出题人和选手之间的AD. bw只想着赶快修好环境, 也忘记先导出日志抓人, 日志又被重定向到了stdout, 重启一下docker啥都没了, 最后想起来的时候人也没抓着, 比赛也快结束了. 初赛过程中自动分发插件倒工作良好, 没出什么幺蛾子. 复赛的账号分发任务交给我来做了, 采用自动注册脚本没费什么力气, 然后发送邮件拜托洛千用工具人做法全部发送到了选手的邮箱. 自动分发插件依旧沿用初赛的插件. Frank收集了所有web和pwn题目之后采用CTFd-Whale插件把题目弄成了动态的, 选手启动自己专属的docker环境做题, flag也各不相同, 防止作弊的同时也有效避免了初赛选手删flag的问题. PPC评测由于Windows下换行符CRLF的问题导致测试题目部分选手写的代码没有通过, 不过没什么大碍. 整个复赛过程中平台运行情况挺稳定的, 整个复赛过程中动态题目总共创建了487次docker环境, 其中用于测试题目创建了51次, 选手解题创建了436次, 其中陈培琛启动了35次题目环境, 杜厚德启动了32次, 陈鸿嘉启动了29次, 在\"浪费服务器性能排行榜\"上夺得前三. ","date":"2020-09-21","objectID":"/posts/mssctf_2020_memos/:1:0","tags":["CTF","Memo"],"title":"MssCTF 2020 赛后总结","uri":"/posts/mssctf_2020_memos/"},{"categories":["Memo"],"content":"逆向出题 初赛逆向题目放出了三道, 有两道题目是我出的, 考点分别是指令虚拟化和全排列, 难度中等, 没爆0. 复赛题目放出了四道, 上午Java逆向和花指令, Java逆向是一个六元一次方程组求解, 两解; flower直接爆0了. 下午本来准备上happy出的一道vm, 但是上午看了看解题情况, 吓得不敢放了, 于是临时出了一个签到题, F5就能看见flag 的那种. 加上一道换表base64解密, 下午成功没有爆0. 有一说一题目质量出的有点低了… 没把握好选手的整体水平, 最后导致题目难度极不合理. ","date":"2020-09-21","objectID":"/posts/mssctf_2020_memos/:2:0","tags":["CTF","Memo"],"title":"MssCTF 2020 赛后总结","uri":"/posts/mssctf_2020_memos/"},{"categories":["Memo"],"content":"总结 这大概是我参与命题的第四场比赛, 我参与运维的第二场比赛, 总体感觉挺良好的, 就是有点浪费肝. 经验大概就是要好好把握选手的水平, 以后出题争取能把难度梯度设置的更合理. 运维方面可能就是要提前准备好, 预留足够多的时间, 把平台整好. 本次比赛期间我同时在维护新生赛MoeCTF的平台, 初赛前一周还在搭建MSC微软俱乐部的招新网站, 以及维护了一个福利题平台, 加上MssCTF反作弊插件的编写, 网信实验班的作业记录平台, QQ机器人, 还有战队考核等其他乱七八糟的事情, 这仨星期通宵了不知道多少次, 感觉生命值快烧完了都. 现在看了看时间表, 除了满满当当的课程之外好像没别的什么大任务了. 一定要好好调整作息, 免得英年早逝 PS: 初赛复赛总共蹭了五顿饭和一堆零食, 真好吃.jpg ","date":"2020-09-21","objectID":"/posts/mssctf_2020_memos/:3:0","tags":["CTF","Memo"],"title":"MssCTF 2020 赛后总结","uri":"/posts/mssctf_2020_memos/"},{"categories":["CTF"],"content":"如题 ","date":"2020-08-07","objectID":"/posts/post/:0:0","tags":["CTF","Web"],"title":"POST","uri":"/posts/post/"},{"categories":["CTF"],"content":"POST是什么? POST是一种HTTP请求方法, 通过网址中的参数来向服务器请求相应的网络资源. 更详细的HTTP请求方法介绍, 请见: MDN文档 ","date":"2020-08-07","objectID":"/posts/post/:1:0","tags":["CTF","Web"],"title":"POST","uri":"/posts/post/"},{"categories":["CTF"],"content":"如何POST? POST本质上和GET都属于给网站提供数据的请求方法. 只不过GET请求可以通过在网址后面直接构造的方法来使用, 十分的简单便捷. 而POST不同, POST是一种有报文的请求方式, 正常用户是无法显式看见POST请求的详细信息的. POST的方法有很多种, 我们只挑两种来讲. ","date":"2020-08-07","objectID":"/posts/post/:2:0","tags":["CTF","Web"],"title":"POST","uri":"/posts/post/"},{"categories":["CTF"],"content":"使用Postman工具 打开Postman, 界面大致如下: 如上设置好你的数据, 就可以非常方便的向服务器发送请求了. ","date":"2020-08-07","objectID":"/posts/post/:2:1","tags":["CTF","Web"],"title":"POST","uri":"/posts/post/"},{"categories":["CTF"],"content":"使用Python的Requests库 使用Python的requests库是最灵活也是CTF中最常用的方法. 安装requests库 确保你的电脑上有Python3; $ python3 -m pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple 请注意! 不要将requests错误的写为request, request库近期被检出投毒: 链接 如果你使用Linux, 也可以在对应发行版的软件仓库里找到requests库的安装包. 例如Arch Linux: $ sudo pacman -Syyu python-requests 即可安装requests库. 尽量使用发行版的包管理器, 这样包管理器更新时会一并检查这些包并自动升级. 如果使用pip, 可能还需要隔一段时间手动更新以修复一些bug, 获得新的功能. 使用requests 使用如下脚本即可简单的对一个网站进行请求: import requests payload = {\"key\" : \"value\"} url = \"https://www.example.com\" response = requests.post(url, data=payload) # 发送请求 print(response.text) # 输出响应主体 print(response.headers) # 输出HTTP响应头 requests库的用法十分丰富, 还可以使用session来维持一个会话, 请熟练掌握. 关于更高级的用法本文不再介绍, 请阅读requests官方文档 ","date":"2020-08-07","objectID":"/posts/post/:2:2","tags":["CTF","Web"],"title":"POST","uri":"/posts/post/"},{"categories":["CTF"],"content":"如题 ","date":"2020-08-06","objectID":"/posts/get/:0:0","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"GET是什么? GET是一种HTTP请求方法, 通过网址中的参数来向服务器请求相应的网络资源. 更详细的HTTP请求方法介绍, 请见: MDN文档 ","date":"2020-08-06","objectID":"/posts/get/:1:0","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"如何GET? 抬头, 看浏览器上的网址. 网址大概为如下构造: 例如https://www.baidu.com/s?wd=hello\u0026rqlang=cn这个网址, 可以访问百度并得到hello的搜索结果. https:// www.baidu.com /s ? wd=hello \u0026 rqlang=cn 超文本传输协议 目标网站 网站目标文件 GET方法提示符 第一个参数 参数分隔符 第二个参数 我们挨个介绍. ","date":"2020-08-06","objectID":"/posts/get/:2:0","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"Q: 超文本传输协议是什么? 这个还是百度吧, 与本文关系不大. ","date":"2020-08-06","objectID":"/posts/get/:2:1","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"Q: 网站目标文件是什么意思? 当你访问一个网址时, 目标网站的域名会将你引导到目标网站的服务器. 在目标网站的服务器上会有一个用来存放网站文件的根目录, 网站目标文件就代表你要访问的文件相对于这个根目录的路径. 这就和你打开我的电脑, 发现自己存的那些涩图在E:\\pictures下面一样, 如果把E:\\当做网站文件根目录, 那么/pictures/xxx.jpg就可以访问到你的涩图. 不过请注意, 有时候访问网站时, 目标文件不一定是一个真实存在的文件. ","date":"2020-08-06","objectID":"/posts/get/:2:2","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"Q: 方法提示符又是个什么鬼? 这个名字是我自己取的. 查了好久也没查到这个问号的官方名字叫什么. 这个问号是用来分割目标文件路径和参数的. ","date":"2020-08-06","objectID":"/posts/get/:2:3","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"Q: 参数是干什么的? 参数是用来传递数据的. 参数的一般格式为: \u003ckey\u003e=\u003cvalue\u003e, 你所提供的参数会提交给网站目标文件进行处理, 你看到的就是处理之后的页面. 多个参数之间使用\u0026连接. ","date":"2020-08-06","objectID":"/posts/get/:2:4","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":"总结 于是https://www.baidu.com/s?wd=hello\u0026rqlang=cn这个网址就可以解释为: 访问百度网站下的s文件, 并将wd参数设置为hello, 将rqlang参数设置为cn, 然后传递给s文件, 这个文件会处理参数后向你的浏览器返回内容, 你就看见了一个网页. 这个网址的意思就是以中文在百度中搜索hello. GET方法就是这样了. 通过网址后面加上?key=value, 并通过浏览器或者其他网络工具进行访问, 就是对网站进行了一次GET请求. ","date":"2020-08-06","objectID":"/posts/get/:3:0","tags":["CTF","Web"],"title":"GET","uri":"/posts/get/"},{"categories":["CTF"],"content":" 逆向工程入门指北, Copyright @ 2020 Reverier, XDSEC for MoeCTF beginners only. ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:0:0","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"逆向工程是什么? 简而言之, 你可以把逆向工程理解为从产品倒推设计方案的一门技术. 这是一门比较黑客向的东西, 想尽办法恢复别人深藏在产品中的设计思想, 并收归己用or进行更深层次的破解与利用. CTF中的逆向工程指的都是软件逆向工程, 逆向的对象不仅包括你最常见的Windows或者Linux操作系统上的那些二进制文件, 也包括安卓的安装包, 物联网设备的固件, 形形色色的中间语言(例如Java的class文件, 既不属于机器代码, 也不属于人类可读的代码, 而是一种能够运行在Java Runtime, 也成为Java虚拟机JVM的东西上的字节码), 总之一切能隐藏逻辑, 并具有执行特定功能的文件, 都是软件逆向工程的目标. ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:1:0","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"我要从哪里开始呢? 就从最简单的Hello World开始吧. 逆向工程是一个逆向的过程, 那正向是什么呢? 没错, 是编程. 也许你不会编程, 但是歪打正着做对了一些题, 这是可以的, 但你越往下走, 就越艰难. 你要熟悉正向过程, 才能在逆向分析中游刃有余. 所以, 如果你还不会C语言, 请现在开始学习编程吧. 入门编程请从C语言开始. ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:0","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"为什么选择C语言 可是为什么不用人生苦短的Python呢? 为什么不从C++开始呢? 为什么不从其他更加高级/现代的语言开始呢? 你可能会有这样的疑问, 没错, 编程考验的是逻辑处理能力, 但是逆向并不只是逻辑处理. 你需要更贴近计算机的运行原理. C语言在保证贴近高级语言的同时, 提供了足够底层的支持, 并且C语言的结构相对简单, 没有类与对象等各种复杂特性, 因此更适合拿来理解计算机执行程序的原理. 更高级的语言你学着挺舒服, 学完了一问运行原理你还是啥都不知道, 即使你想去了解也很难, 高级语言的实现过程一般都是你想象不到的复杂. 同时C语言具有设计上的缺陷, 但绝大部分的其他高级语言的解释器/编译器/运行时还是使用C语言编写出来的, 学会C语言之后再去入门其他的语言门槛会低很多, 但是你先学Python再学C, 你会发现C比你想象中的要难, 所以入门编程请从C语言开始. 如果上面说了这么多都无法打动你的话, 那么接下来的话你听好了: C语言是大一上学期必修课, 并且在你整个大学过程中都阴魂不散, 这下你该去学了吧? ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:1","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"学了一点C语言之后呢? 接下来你就可以尝试着上手逆向工程题目了. 有个叫做IDA的工具可以帮你把神必的机器代码变成汇编语言, 还能帮你把让人头晕的汇编语言变成类似C语言的代码. 接下来你就可以安心的分析程序逻辑了, 这就像是在看别人的代码, 然后揣度别人的意思一样, 通过分析程序内部的算法, 再运用一点逻辑和数学的知识, 你就能成功的把隐藏的信息给挖出来. 关于IDA如何使用, 我们就不再介绍了, 篇幅写不下, 本文只是给你指明一个方向, 具体使用方法还需要你自己通过谷歌或者百度一步步探索, 作为学长我可以为你引路, 但不能当你的老师/保姆呀. 至于资源去哪里找, 下一题有IDA的资源链接. ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:2","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"逆向题一般是什么套路? 我们不从逆向工程师的角度来看, 我们从一个软件开发者的角度来看. 比如让你写一个密码验证器, 你会怎么做? strcmp(input, \"this_is_password\"); 你可能会这么写, 但是这样写毫无逻辑可言, 就是简单的字符串比对. 你编译一下扔进IDA, 然后按下F5键, 你就能发现你的密码就躺在程序里, 可以被轻松破解掉. 那安全一点的写法呢? 你可以用各种算法来保证你的数据没有那么容易被别人给搞出来, 比如你可以使用异或: char password_enc[] = {98, 126, 127, 101, 73, 127, 101, 73, 102, 119, 101, 101, 97, 121, 100, 114}; // password_enc的每一位和22进行异或, 就能得到真实的密码\"this_is_password\" for (int i = 0; i \u003c 16; i++) { if (input[i] ^ 22 != password_enc[i]) { printf(\"Password is wrong!\\n\"); exit(0); } } printf(\"Password is right!\\n\"); 虽然这个算法也很简单, 但编译之后的破译难度是不是增加了? 那么作为一个逆向手, 你的主要工作就是: 找到目标数据, 无论是加密过的还是没有加密过的 从你的输入开始, 逐步分析他的代码都干了些什么, 一直到输出的位置 把算法抽象出来, 理解他究竟对目标数据做了什么 尝试通过写出逆算法, 把加密的目标数据成功还原为加密前的数据. 例如上面那个异或数据的例子, 我们就很容易破解: // 因为a^b=c时, b^c=a, 所以我们可以这样还原数据: char password_enc[] = {98, 126, 127, 101, 73, 127, 101, 73, 102, 119, 101, 101, 97, 121, 100, 114}; char password[17]; for (int i = 0; i \u003c 16; i++) { password[i] = password_enc[i] ^ 22; } password[16] = 0; printf(\"%s\\n\", password); 简单吧. 真实做题中你会逐渐遇到更难的加密方式与算法, 这不仅要求你的编程能力要逐步提高, 还要求你要有耐心, 逆向的过程一般都是冗长而无聊的, 但是解出题目那一瞬的快感可以让你高兴一整天(我是这样的). ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:3","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"你说的好像挺简单, 但是好像不是所有题目都长这样啊 当然. 我前面介绍过, 任何能够执行的文件都是我们逆向的目标, 所以针对不同语言, 我们有不同的工具. 遇到新的逆向题目不要害怕, 越是古怪的题目可能越简单. 这个时候搜索引擎就派上大用场了, 你可以找到各种形形色色的工具, 但最终还是要回归到上面讲的逻辑分析上. ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:4","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["CTF"],"content":"逆向只有这些嘛? 并不, 随着软件保护技术的发展, 先后出现了加壳, 花指令, 指令虚拟化, 虚拟机等等等各种更加高级的保护手法, 有时候可能IDA也对这些保护束手无策. 你可能还需要动态调试工具, 通过程序运行一步一步分析在保护之下的真实逻辑, 你可能也需要脱壳工具来帮助你脱掉程序的保护壳, 有时候脱壳工具也不管用, 你还需要了解手动脱壳……你以为我会在这里给你全部说一遍嘛? 不可能的, 说完我都可以出书了. 我的目标已经达成了,万事开头难, 我只想帮你迈出第一步, 后面的探索过程就留给你自己啦. 学会用搜索引擎, 并在搜索引擎无能为力时懂得找学长寻求帮助, 你的进步一定会非常快的. 但学习逆向工程的路不会很顺利, 请做好准备哦~ 加油, 祝你在逆向工程领域能取得好成绩! 本题flag: moectf{0hhhhhhh_I_kn0w_hoW_t0_R3v3rs3!} ","date":"2020-08-01","objectID":"/posts/reverse_tutorial/:2:5","tags":["CTF"],"title":"逆向工程入门指北 for MoeCTF 2020","uri":"/posts/reverse_tutorial/"},{"categories":["Learning"],"content":"数组索引, 倒过来还是索引 由于数组索引被解释成指针+偏移, 所以我们用偏移+指针也未尝不可. #include \u003ciostream\u003e using namespace std; int main () { int a[] = {1, 2, 3, 4, 5, 6, 7}; cout \u003c\u003c \"a[4]: \" \u003c\u003c a[4] \u003c\u003c endl; cout \u003c\u003c \"4[a]: \" \u003c\u003c 4[a] \u003c\u003c endl; return 0; } ","date":"2020-07-05","objectID":"/posts/cpp_learning_1/:1:0","tags":["C++","Learning"],"title":"C++的一些神奇用法","uri":"/posts/cpp_learning_1/"},{"categories":["Learning"],"content":"lambda 的无限套娃 int main(){[](){[](){[](){[](){[](){ cout\u003c\u003c\"Hello World\"\u003c\u003cendl; }();}();}();}();}();} 转自C++新标准中有哪些浪到没朋友的新写法？ - 王维一的回答 - 知乎 ","date":"2020-07-05","objectID":"/posts/cpp_learning_1/:2:0","tags":["C++","Learning"],"title":"C++的一些神奇用法","uri":"/posts/cpp_learning_1/"},{"categories":["Learning"],"content":"像Python一样迭代 // When you are using C++ 98: circle *p = new circle(42); vector\u003cshape*\u003e v = load_shapes(); for (vector\u003cshape*\u003e::iterator i = v.begin(); i != v.end(); i++) if (*i \u0026\u0026 **i == *p) cout \u003c\u003c **i \u003c\u003c\"is a match\\n\"; for (vector\u003cshape*\u003e::iterator i = v.begin(); i != v.end(); i++) delete *i; delete p; // When you are using the new C++ 17 auto p = make_shared\u003ccircle\u003e(42); auto v = load_shapes(); for (auto \u0026s : v) if (s \u0026\u0026 *s == *p) cout \u003c\u003c *s \u003c\u003c \"is a match\\n\"; 转自YouTube 除了标准支持的for自动迭代器之外，还有std::for_each(container.begin(), container.end(), predicate_function)与Qt的for_each(item, container)可用。不过有了新标准之后这种写法更容易理解，并且没有对库的依赖性。 ","date":"2020-07-05","objectID":"/posts/cpp_learning_1/:3:0","tags":["C++","Learning"],"title":"C++的一些神奇用法","uri":"/posts/cpp_learning_1/"},{"categories":["Learning"],"content":"强大到没朋友的auto 据说2038年的C++标准就可以支持这么写了： auto [auto](auto auto) auto { auto(auto auto{auto}; auto \u003c auto; auto++) auto[auto] = auto; auto auto; } (这个代码就是开个玩笑) 看上一节中的应用，auto几乎万能。 ","date":"2020-07-05","objectID":"/posts/cpp_learning_1/:4:0","tags":["C++","Learning"],"title":"C++的一些神奇用法","uri":"/posts/cpp_learning_1/"},{"categories":["Learning"],"content":"像for一样在if和while里使用变量初始化 if (false; true) { std::cout \u003c\u003c \"Hello World~!\" \u003c\u003c std::endl; } // 可以输出 if (auto i = func(parameters); judge(i)) { // do something... } // 根据judge()函数的判断决定要不要执行 ","date":"2020-07-05","objectID":"/posts/cpp_learning_1/:5:0","tags":["C++","Learning"],"title":"C++的一些神奇用法","uri":"/posts/cpp_learning_1/"},{"categories":["Learning"],"content":"对C++虚函数的概念做一个简单的了解. ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:0:0","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"介绍 ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:1:0","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"虚函数 虚函数指在基类使用virtual关键字声明的成员函数, 在使用对象指针时, 允许用基类的指针来调用子类的这个函数. ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:1:1","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"纯虚函数 定义一个函数为纯虚函数, 代表该函数在基类中只有声明, 但是没有被实现. 子类必须对此函数进行重写才能够使用, 与此同时, 基类由于没有提供纯虚函数的具体实现, 所以无法被实例化为对象而使用. 一、定义 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加\"=0\" virtual void funtion1()=0; 二、引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。 纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。 纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。 来自虚函数和纯虚函数的区别-hackbuteer1 ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:1:2","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"抽象类 带有纯虚函数的类被称为抽象类. 抽象类只能作为基类被继承, 同时如果子类也没有提供该类中纯虚函数的定义, 那么子类也是一个抽象类. 抽象类不能被实例化为对象来使用. ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:1:3","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"实验 // virtualFunc.cpp 虚函数实验 #include \u003cstdio.h\u003e class Father { public: virtual void virtualFunc() { printf(\"Virtual Function of Father class\\n\"); } void commonFunc() { printf(\"Common function of Father class\\n\"); } }; class Son : public Father { // Father必须使用public关键字修饰, 否则为不可访问的基类 public: virtual void virtualFunc() { printf(\"Virtual Function of Son class\\n\"); } void commonFunc() { printf(\"Common function of Son class\\n\"); } }; int main () { Father *p = new Son(); p-\u003evirtualFunc(); p-\u003ecommonFunc(); return 0; } 结果: ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:2:0","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Learning"],"content":"结尾 Apache553大哥说的没错, C++是永远学不完的. ","date":"2020-06-18","objectID":"/posts/cpp_virtual_function/:3:0","tags":["C++","Learning"],"title":"C++ 虚函数","uri":"/posts/cpp_virtual_function/"},{"categories":["Workspace"],"content":"如题 [FAILED] Failed to activate swap /swapfile. [DEPEND] Dependency failed for Swap. 开机时报错如上, 开机之后交换文件无法正确被挂载. 在Arch Linux论坛上找到了解决方案如下: SOLVED: Swap not working with Kernel 5.7.2 这个问题仅出现在ext4文件系统下的 Linux 5.7.2 上, 使用fallocate 创建的swap交换文件. Arch Linux Wiki的解释如下: Note: dynamic space allocation such as using fallocate is not supported, as it causes problems with some file systems such as F2FS[1] and will likely fail to activate at boot time with error “swapon: swapfile has holes” as of kernel 5.7. Hence, contiguous allocation, such as dd, is the only reliable way to allocate a swap file.[2] 因此删掉原有的swapfile, 用dd重新分配即可. sudo dd if=/dev/zero of=/swapfile bs=1M count=4096 status=progress sudo chmod 600 /swapfile sudo mkswap /swapfile sudo swapon /swapfile ","date":"2020-06-12","objectID":"/posts/linux_57_swapfile_bugs/:0:0","tags":["Linux","Workspace"],"title":"Linux 5.7.2 swapfile 无法挂载的解决方案","uri":"/posts/linux_57_swapfile_bugs/"},{"categories":["Workspace"],"content":"如题. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:0:0","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"前言 从折腾好笔记本上的独立显卡到目前已经稳定运行了四个多月左右, 写一下大概的解决方案. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:1:0","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"Nvidia-Prime Nvidia-Prime是Nvidia官方给Linux用户施舍的兼容Optimus显卡的解决方案. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:2:0","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"原因 我的笔记本配置: 如图. 由于混迹于哔哩哔哩某些原因需要进行视频渲染, 本身又是个码农, 还是个在校学生, 上个网课之类的, 平时还要背着电脑到处跑, 于是就需要寻找一个完美点的显卡解决方案. 尝试过Bumblebee, 由于要配合bbswitch使用, 而我的笔记本由于比较特殊, 无法用软件开启或者关闭显卡; 可以从BIOS关闭显卡, 但是每次都很麻烦; 显卡状态改变后笔记本需要彻底断电然后冷启动才能够正确的加载显卡活动… 于是最终就只能抛弃了Bumblebee. 就在不久之前, Linus宣布发布Linux 5.6, 介绍中加入了对RTX系列显卡的支持. Nvidia官方又推出了更新进度虽然缓慢但有总比没有好的Nvidia-Prime供Linux用户使用, 在Linux上折腾显卡才显露出一丝曙光. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:2:1","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"过程 $ sudo pacman -Syyu nvidia nvidia-prime nvidia-settings nvidia-utils 好了, 没有了. 这几个包可以让你的显卡转起来了. 美中不足的就是它不能有效的关停显卡, 而是让显卡以省电模式继续转. 运行需要独立显卡的程序时, 使用prime-run xxx即可. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:2:2","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"一些软件适配 Davinci Resolve Davinci Resolve需要安装opencl-nvidia才能够正常运行. 否则会报ld4CXX相关的错误. $ sudo pacman -Syyu opencl-nvidia Davinci Resolve启动前有一定延迟, 耐心等待即可. Osu! Lazer 使用prime-run osu-lazer之后, 调整窗口为全屏. Minecraft Launcher (Offcial, HMCL) 卸载Noto Sans系字体, 否则打开launcher之后界面会保持黑色, 游戏启动时会异常crash. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:2:3","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"已知BUG/影响使用体验的现象 Davinci Resolve 调出某些子窗口时全部黑屏, 摸索着关掉子窗口之后恢复正常. 例如剪辑panel中试图更改片段时长, 或者片段速度时, 在你右键菜单选中这一项并按下时整个屏幕会黑掉. 按一下Esc则又会恢复. 无法使用Fcitx进行中文输入. ibus没有测试. 可能的解决方案: 可以尝试使用Bumblebee(不带bbswitch)与primusrun. 使用primusrun运行的Davinci Resolve不会出现此类BUG. 但是primusrun与Bumblebee模块的性能较低, 使用Fusion制作一些复杂一点的特效时, Davinci Resolve会崩溃. Osu! Lazer 桌面特效会被强制关闭. 无法输入中文. Minecraft Launcher (Offcial) 无法输入中文. 无论是否用独立显卡运行, 都不能输入中文. Wine 使用prime-run运行的wine应用程序无法在全屏显示状态下输入中文. 非全屏显示时没有问题. 使用独显运行时字体渲染有些发虚. CUDA 需要使用CUDA的软件包在安装CUDA之后使用时性能损耗明显, 并且崩溃有些频繁, 只能先凑合着用… ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:2:4","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["Workspace"],"content":"结尾 如果你有什么更好的解决方案, 希望能提供在评论区, 不胜感谢. ","date":"2020-05-25","objectID":"/posts/nvidia_drivers_solution/:3:0","tags":["Linux","Workspace"],"title":"Nvidia Prime的最终折腾方案","uri":"/posts/nvidia_drivers_solution/"},{"categories":["CTF"],"content":"wp Mini L CTF WP by arttnba3 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:0:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"hello 证明了我真的是菜鸡的一道pwn题，搞了半天才明白XD 做题环境Manjaro-KDE 首先使用checksec指令查看保护，可以发现保护基本都是关的，只有Partial RELRO，那么基本上是可以为所欲为了wwww win环境下拖进IDA进行分析 可以发现在vul函数存在明显的栈溢出 main函数中调用了vul 那么程序漏洞很明显了： 使用fgets读入最大为72个字节的字符串，但是只分配给了48字节的空间，存在栈溢出 又有一个可疑的bd函数，那么第一时间想到**ret2text**——构造payload跳转到bd 但是很明显，bd函数基本是是空的(悲) 然后我就在这里卡了半天，证明我真的菜XD 那么我们该如何利用这个bd呢？ 可以看到在bd中存在操作jmp rsp，那么其实我们可以利用这个指令跳转回栈上，执行我们放在栈上的shellcode 也就是说这其实是一道ret2shellcode的题 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:1:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"ret2text执行过程： rsp永远指向栈顶 当我们用常规的ret2text构造48字节字符串+8字节rbp+8字节bd函数地址（覆盖掉原返回地址）的payload时，rsp指向的其实是bd函数地址的位置 ret指令进入bd后弹出bd地址，rsp指向栈内储存的rbp的值（预期内） bd函数将rbp再push入栈中，此时rsp再加8，指向被新压入的rbp（预期内） bd函数执行rsp上的指令 那么我们就可以在rsp预期内指向的地址上覆盖上我们的shellcode使其被执行 接下来就是ret2shellcode的： ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:1:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"ret2shellcode修正过程： 在rsp最终指向的地址放上我们待执行的shellcode 由于长度不够，我们可以把getshell的shellcode放在读入的字符串的最开始的地方，再通过汇编指令进行跳转 在rsp所指向的位置覆盖上shellcode，改变rsp的值使其指向getshell的shellcode并再次进行跳转，完成getshell 那么payload就很容易构造出来了： context.arch = 'amd64' sc1 = asm(shellcraft.sh()) sc2 = asm('sub rsp,64')//48字节的字符串+8字节的rsp+8字节的rbp，跳回开头 sc3 = asm('jmp rsp') elf = ELF('hello') payload = sc1 + b'a'*(56-len(sc1)) + p64(elf.symbols['bd']) + sc2 + sc3 Mini L CTF Writeup by luoqi@n ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:1:2","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"Sign in 看源码就送flag ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:2:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"Web id_wife 这个还真挺好玩的，把认识的师傅id都输了一遍，直到我把自己的id输了进去（草 这里拿小sad举例： 看见这个，我立刻想到了强网杯的随便注（其实找了半天），因为那道题用到了堆叠注入的知识点，所以我就试了一下 sad'); show databases; 成了，再试一下查询表 sad'); show tables; 这个看起来这么臭的表一定有问题（确信 这里我用到了handler，这条语句使我们能够一行一行的浏览一个表中的数据，所以： sad');handler`1145141919810`open;handler`1145141919810`read first; 好的给了个假flag…再读取下一条 sad');handler`1145141919810`open;handler`1145141919810`read first;handler`1145141919810`read next; 直接给出flag（因为是动态flag所以不贴了 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:3:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"reverse EPL-Fish 这道题还不如放到misc里去…一点逆向都没用到 下载文件发现这玩意是用来钓鱼的假qq登陆界面，于是随便输入账号密码试了一下 草这钓鱼界面太真实了，用wireshark抓包试试看 可以看到这个程序用smtp协议登录邮箱，将用户输入的账号和密码发送到dengluwo233@163.com这个邮箱。由于smtp协议登录时的账号和密码默认为base64编码加密，所以我们很容易得到邮箱密码：FGYYJTMAZVTUPSWH 但是邮箱的账号和密码在网页登录的时候显示密码错误，163邮箱的密码也默认必须由数字字母组成，这个密码明显不符合，但是后来RX大哥用客户端登录成功了，于是问了下出题人，这里贴一下： 登录成功后，在收件箱发现一个压缩包：thing.zip，打开之后在其中的QQ.e文件里发现flag miniL{Epl_Oh_gre@T} ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:4:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"Misc MiniGameHacking 这游戏好玩得很（虽然为了抢一血解法非常暴力 在data.unity3d文件里人 肉 搜 索到的flag（因为flag的minil少了一个m，搜索minil是搜不到的 minil{diosamasayikou} 后来听别人说游戏通关也有flag，一共15关，我打到14关就过不去了只能放弃（ EasyVmem 2G的vmem文件…我要死了草… 本着这么大的文件不可能拖到kali里用Volatility挨个找的想法，我跟ga1@xy嫖了一个windows用的取证工具：Magnet AXIOM，加载了半个多小时之后终于成了 然后在剪贴板里看到了一个假flag和奇怪的东西 假flag里（base64）的大致内容是grep cha113nge to start the game，至于下面那一堆s3cR3t（太多了就不放这了）后面的数字一直在变，从10 10一直到289 289，猜测是289x289像素的图片，于是让RX大哥画了个图： 扫一下就可以获得flag（出题人说他是在volatility环境下设置的题，所以我这算是抄近路了 miniLCTF{mAst3R_0F_v0Lat1l1tY!} MITM_0 这是一个中间人攻击的流量包 这里把192.168.1.152这个ip base64一下交上去就可以了 MITM_1 去查一下common name： 一看这个东西就是跟证书有关的，于是在流量包里搜索certificate issuer，commonname，那这个Liuyukun CA应该就是要找的东西了，base64一下就能得到flag ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:5:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"总结 比赛这么多天，看着RX大哥穿了一道又一道，我就只能划水….混了个第三还是挺开心的 Mini L CTF WP by Reverier ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:5:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"逆向 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:6:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"easy-re 本题就是一个很常规的逆向, 不过F5之后不太好康而已. F5出来的源码: int __cdecl main(int argc, const char **argv, const char **envp) { __m128i v3; // xmm1 __m128i v4; // xmm0 __m128i v5; // xmm1 __m128i v6; // xmm0 __int64 v7; // rdx signed __int64 v8; // rax __int128 v10; // [rsp+20h] [rbp-1B8h] __int128 v11; // [rsp+30h] [rbp-1A8h] __int128 v12; // [rsp+40h] [rbp-198h] __int128 v13; // [rsp+50h] [rbp-188h] __int128 v14; // [rsp+60h] [rbp-178h] __int128 v15; // [rsp+70h] [rbp-168h] char Str[16]; // [rsp+80h] [rbp-158h] char v17[16]; // [rsp+90h] [rbp-148h] __int16 v18; // [rsp+A0h] [rbp-138h] char v19; // [rsp+A2h] [rbp-136h] __int128 v20; // [rsp+A3h] [rbp-135h] __int64 v21; // [rsp+B3h] [rbp-125h] int v22; // [rsp+BBh] [rbp-11Dh] char v23; // [rsp+BFh] [rbp-119h] char v24[256]; // [rsp+C0h] [rbp-118h] v3 = _mm_load_si128((const __m128i *)\u0026unk_140003440); _mm_store_si128((__m128i *)\u0026v10, _mm_load_si128((const __m128i *)\u0026xmmword_140003400)); _mm_store_si128((__m128i *)\u0026v12, _mm_load_si128((const __m128i *)\u0026xmmword_1400033E0)); v4 = _mm_load_si128((const __m128i *)\u0026dword_140003410); _mm_store_si128((__m128i *)\u0026v11, v3); v5 = _mm_load_si128((const __m128i *)\u0026xmmword_1400033F0); _mm_store_si128((__m128i *)\u0026v14, v4); v6 = _mm_load_si128((const __m128i *)\u0026unk_140003430); _mm_store_si128((__m128i *)\u0026v13, v5); _mm_store_si128((__m128i *)Str, v6); v15 = 0i64; v18 = 26727; v20 = 0i64; v19 = 116; _mm_store_si128((__m128i *)v17, _mm_load_si128((const __m128i *)\u0026unk_140003420)); v21 = 0i64; v22 = 0; v23 = 0; puts(Str); cin_read(std::cin, v7, v24); v8 = 0i64; do { if ( v24[v8] != *((_DWORD *)\u0026v10 + v8) + 100 ) { puts(\u0026v17[8]); exit(1); } ++v8; } while ( v8 \u003c 20 ); return puts(\u0026v17[14]); } 程序将输入和v10处的数据+100后进行比对. 相关数据: xmmword_1400033E0 xmmword 10000000E000000150000000Fh .rdata:00000001400033E0 ; DATA XREF: main+39↑r .rdata:00000001400033F0 xmmword_1400033F0 xmmword 1FFFFFFFB0000000FFFFFFFC3h .rdata:00000001400033F0 ; DATA XREF: main+55↑r .rdata:0000000140003400 xmmword_140003400 xmmword 50000000A0000000500000009h .rdata:0000000140003400 ; DATA XREF: main+19↑r .rdata:0000000140003410 dword_140003410 dd 0FFFFFFFDh ; DATA XREF: main+47↑r .rdata:0000000140003414 db 0Fh .rdata:0000000140003415 db 0 .rdata:0000000140003416 db 0 .rdata:0000000140003417 db 0 .rdata:0000000140003418 db 15h .rdata:0000000140003419 db 0 .rdata:000000014000341A db 0 .rdata:000000014000341B db 0 .rdata:000000014000341C db 19h .rdata:000000014000341D db 0 .rdata:000000014000341E db 0 .rdata:000000014000341F db 0 .rdata:0000000140003420 unk_140003420 db 72h ; r ; DATA XREF: main+8F↑r .rdata:0000000140003421 db 20h .rdata:0000000140003422 db 66h ; f .rdata:0000000140003423 db 6Ch ; l .rdata:0000000140003424 db 61h ; a .rdata:0000000140003425 db 67h ; g .rdata:0000000140003426 db 3Ah ; : .rdata:0000000140003427 db 0 .rdata:0000000140003428 db 77h ; w .rdata:0000000140003429 db 72h ; r .rdata:000000014000342A db 6Fh ; o .rdata:000000014000342B db 6Eh ; n .rdata:000000014000342C db 67h ; g .rdata:000000014000342D db 0 .rdata:000000014000342E db 52h ; R .rdata:000000014000342F db 69h ; i .rdata:0000000140003430 unk_140003430 db 50h ; P ; DATA XREF: main+63↑r .rdata:0000000140003431 db 6Ch ; l .rdata:0000000140003432 db 65h ; e .rdata:0000000140003433 db 61h ; a .rdata:0000000140003434 db 73h ; s .rdata:0000000140003435 db 65h ; e .rdata:0000000140003436 db 20h .rdata:0000000140003437 db 69h ; i .rdata:0000000140003438 db 6Eh ; n .rdata:0000000140003439 db 70h ; p .rdata:000000014000343A db 75h ; u .rdata:000000014000343B db 74h ; t .rdata:000000014000343C db 20h .rdata:000000014000343D db 79h ; y .rdata:000000014000343E db 6Fh ; o .rdata:000000014000343F db 75h ; u .rdata:0000000140003440 unk_140003440 db 8 ; DATA XREF: main+29↑r .rdata:0000000140003441 db 0 .rdata:0000000140003442 db 0 .rdata:0000000140003443 db 0 .rdata:0000000140003444 db 17h .rdata:0000000140003445 db 0 .rdata:0000000140003446 db 0 .rdata:0000000140003447 db 0 .rdata:0000000140003448 db 1 .rdata:0000000140003449 db 0 .rdata:00","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:6:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"machine 我对着题目给出的四串乱七八糟的东西发了两天的呆 最后没办法了去问Frank才发现这道题竟然是要F12康脚本… F12之后拿到脚本, 尝试JS反混淆等皆不成功, 直接分析怎么看也不可能, 于是动态调试, 把题目的脚本中return语句全打上断点, 一步一步调试就能看见flag了. ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:6:2","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"What’s Virtialization 这道题表面上看着是虚拟化, 实际上没发现和虚拟化有什么关系emmmm… F5之后分析的main函数: int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax int v4; // eax int v5; // eax int global_iter; // [esp+D0h] [ebp-2Ch] signed int i; // [esp+DCh] [ebp-20h] signed int j; // [esp+DCh] [ebp-20h] signed int k; // [esp+DCh] [ebp-20h] signed int v11; // [esp+E8h] [ebp-14h] int input_length; // [esp+F4h] [ebp-8h] printf(\"Welcome to MiniLCTF!\\n\"); printf(\"Plz input your flag:\"); scanf_s(\"%s\", input, 100); input_length = strlen(input); v11 = 100; // fibnacci[9]: [1, 1, 2, 3, 5, 8, 13, 21 ,34] if ( fibnacci[0] * fibnacci[0] + input_length * input_length \u003e= fibnacci[0] * input_length * fibnacci[2] \u0026\u0026 or(input_length, fibnacci[1]) == fibnacci[8] - fibnacci[0] )// if input_length == 32 or input_length == 33 { global_iter = 0; for ( i = 0; i \u003c 6; ++i ) { first_proc[i] = xor(input[i], const_array1[global_iter]); global_iter = (fibnacci[0] + global_iter) % (fibnacci[4] + fibnacci[1]);// just iter++ // when iter \u003e 5, iter = 0 if ( and(first_proc[i], const_array2[i]) != first_proc[i] ) { v3 = xor(fibnacci[3] / 3, fibnacci[0]); // v3 = 0 v11 = and(v11, v3); // v11 = 0 } } // just reconize is minil{ or not if ( or(v11, fibnacci[8]) != fibnacci[6] + fibnacci[7] )// False when v11 in [0, 2, 32, 34] { for ( j = 0; j \u003c 13; ++j ) { byte_4060F6[j] = xor(zero_array[j], const_array1[global_iter]); global_iter = (fibnacci[1] + global_iter) % (fibnacci[3] * fibnacci[2]); if ( and(byte_4060F6[j], const_array3[j]) != byte_4060F6[j] ) { v4 = xor(fibnacci[5] / 2 - 3, fibnacci[1]); v11 = and(v11, v4); } } if ( or(v11, fibnacci[7]) != fibnacci[5] + fibnacci[6] ) { for ( k = 0; k \u003c 13; ++k ) { byte_406103[k] = xor(byte_40609B[k], const_array1[global_iter]); global_iter = (global_iter + fibnacci[2] / 2) % (fibnacci[5] - fibnacci[2]); if ( and(byte_406103[k], const_array4[k]) != byte_406103[k] ) { v5 = xor(fibnacci[7] / 7, fibnacci[3]); v11 = and(v11, v5); } } if ( and_utils(v11) != v11 - fibnacci[0] ) { printf(\"\\nCongratulations! Your flag is right!\"); getchar(); } } } } getchar(); return 0; } 其中xor, or和and涉及到一点模电的知识, 很好识别. 常量数组带入后再次简化的程序: #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int or_utils(int a, int b) { return ~a \u0026 ~b; } int and (int a, int b) { int v1, v2; v1 = or_utils(a, a); v2 = or_utils(b, b); return or_utils(v1, v2); } int or (int a, int b) { int v1, v2; v1 = or_utils(a, b); v2 = or_utils(a, b); return or_utils(v1, v2); } int and_utils(int a1) { return or_utils(a1, a1); } int xor(int a, int b) { int v2; // ST08_4 int v3; // eax v2 = or_utils(a, b); v3 = and(a, b); return or_utils(v3, v2); } int fibnacci[9] = {1, 1, 2, 3, 5, 8, 13, 21, 34}; int main() { int v3; int v4; int v5; int global_iter; signed int i; signed int j; signed int k; signed int is_ok; int input_length; char input[105]; char first_proc[7] = {}; char arr_020408[7] = \"020408\"; char const_array2[7] = \"}[^]}{\"; char const_array3[14] = \"dtKcXxDmYgoNY\"; char const_array4[14] = \"@D]pTYHp@Yw^O\"; char second_proc[14] = {}; char third_proc[86] = {}; printf(\"Welcome to MiniLCTF!\\n\"); printf(\"Plz input your flag:\"); scanf(\"%s\", input); input_length = strlen(input); is_ok = 100; // fibnacci[9]: [1, 1, 2, 3, 5, 8, 13, 21 ,34] global_iter = 0; if (input_length == 32 || input_length == 33) { for (i = 0; i \u003c 6; ++i) { first_proc[i] = input[i] ^ arr_020408[global_iter]; global_iter++; // just iter++ if (global_iter \u003e 5) global_iter = 0; // when iter \u003e 5, iter = 0 if (and(first_proc[i], const_array2[i]) != first_proc[i]) { v3 = 0; // v3 = 0 is_ok = 0; // is_ok = 0 } } if (is_ok) { //global_iter = 0 now. for (j = 0; j \u003c 13; ++j) { second_proc[j] = arr_020408[global_iter]; global_iter = (1 + global_iter) % 5; //global_iter is in [0, 1, 2, 3, 4, 5] if (and(second_proc[j], const_array3[j]) != second_proc[j]) { v4 = 0; is_ok = 0; } } if (is_ok) { for (k = 0; k \u003c 13; ++k) { third_proc[k] = arr_020408[global_iter]; global_iter = (global_iter + 1) % 5; if (and(third_proc[k], const_array4[k]) != third_proc[k]) {","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:6:3","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"安卓 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:7:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"TestOnly 用dex2jar导出为jar之后拖入到jd-gui, 发现就是个简单的算法题. 不过查了好久也没查到Java中的SHA代指SHA几, 最后索性直接复制下来跑出答案. import java.nio.charset.StandardCharsets; import java.security.MessageDigest; public class test { public static int a(char paramChar) { int i; if (paramChar \u003c '') { i = paramChar; } else { i = a(Character.toString(paramChar)); } return i; } public static int a(String paramString) { int i = paramString.length(); int j = 0; if (i \u003e 0) j = paramString.getBytes(StandardCharsets.UTF_8)[0] \u0026 0xFF; return j; } public static String b(String paramString) { try { MessageDigest messageDigest = MessageDigest.getInstance(\"SHA\"); byte[] arrayOfByte = messageDigest.digest(paramString.getBytes(\"UTF-8\")); StringBuffer stringBuffer = new StringBuffer(); for (byte b = 0; b \u003c arrayOfByte.length; b++) { int i = arrayOfByte[b] \u0026 0xFF; if (i \u003c 16) stringBuffer.append(\"0\"); stringBuffer.append(Integer.toHexString(i)); } return stringBuffer.toString(); } catch (Exception exception) { System.out.println(exception.toString()); exception.printStackTrace(); return \"\"; } } public static String J() { String str = \"\"; try { String str1 = b( \"B08020D0FACFDAF81DB46890E4040EDBB8613DA5ABF038F8B86BD44525D2E27B26E22ACD06388112D8467FD688C79CC7EA83F27440577350E8168C2560368616\"); str = str1; } catch (Exception exception) { exception.printStackTrace(); } char[] arrayOfChar = new char[30]; arrayOfChar[0] = 'U'; arrayOfChar[1] = '_'; arrayOfChar[2] = '\\005'; arrayOfChar[3] = 'S'; arrayOfChar[4] = 'K'; arrayOfChar[5] = '`'; arrayOfChar[6] = '^'; arrayOfChar[7] = Character.MIN_VALUE; arrayOfChar[8] = '\\021'; arrayOfChar[9] = '='; arrayOfChar[10] = 'f'; arrayOfChar[11] = 'W'; arrayOfChar[12] = 'P'; arrayOfChar[13] = '{'; arrayOfChar[14] = '\\004'; arrayOfChar[15] = 'i'; arrayOfChar[16] = 'U'; arrayOfChar[17] = 'S'; arrayOfChar[18] = 'e'; arrayOfChar[19] = 'm'; arrayOfChar[20] = '7'; arrayOfChar[21] = 'U'; arrayOfChar[22] = '\\027'; arrayOfChar[23] = '0'; arrayOfChar[24] = 'j'; arrayOfChar[25] = '\\001'; arrayOfChar[26] = '('; arrayOfChar[27] = '\\007'; arrayOfChar[28] = 'a'; arrayOfChar[29] = '\\037'; for (byte b = 0; b \u003c arrayOfChar.length; b++) arrayOfChar[b] = (char) (char) (arrayOfChar[b] ^ a(str.charAt(b))); return String.copyValueOf(arrayOfChar).replace(\"flag\", \"minil\"); } public static void main(String[] args) { System.out.println(J()); } } ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:7:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"Misc ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:8:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"EasyVmem 这道题是由我和luoqi@n共同完成的. 首先要从Vmem中提取出剪贴板数据, 导出了一个巨大的txt: s3cR3t:10 10 s3cR3t:10 11 s3cR3t:10 12 s3cR3t:10 13 s3cR3t:10 14 s3cR3t:10 15 s3cR3t:10 16 s3cR3t:10 17 s3cR3t:10 18 s3cR3t:10 19 s3cR3t:10 20 s3cR3t:10 22 s3cR3t:10 23 s3cR3t:10 24 s3cR3t:10 25 s3cR3t:10 26 s3cR3t:10 27 s3cR3t:10 28 s3cR3t:10 29 s3cR3t:10 30 s3cR3t:10 31 s3cR3t:10 33 s3cR3t:10 34 s3cR3t:10 35 s3cR3t:10 36 s3cR3t:10 37 s3cR3t:10 38 s3cR3t:10 39 s3cR3t:10 40 s3cR3t:10 41 s3cR3t:10 42 s3cR3t:10 44 s3cR3t:10 45 s3cR3t:10 46 s3cR3t:10 47 s3cR3t:10 48 s3cR3t:10 49 s3cR3t:10 50 s3cR3t:10 51 s3cR3t:10 52 s3cR3t:10 53 s3cR3t:10 55 s3cR3t:10 56 s3cR3t:10 57 s3cR3t:10 58 s3cR3t:10 59 s3cR3t:10 60 s3cR3t:10 61 s3cR3t:10 62 s3cR3t:10 63 s3cR3t:10 64 s3cR3t:10 65 s3cR3t:10 66 s3cR3t:10 67 s3cR3t:10 68 s3cR3t:10 69 s3cR3t:10 70 s3cR3t:10 71 s3cR3t:10 72 s3cR3t:10 73 s3cR3t:10 74 s3cR3t:10 75 s3cR3t:10 76 s3cR3t:10 78 s3cR3t:10 79 s3cR3t:10 80 s3cR3t:10 81 s3cR3t:10 82 s3cR3t:10 83 s3cR3t:10 84 s3cR3t:10 85 s3cR3t:10 86 s3cR3t:10 87 s3cR3t:10 100 s3cR3t:10 101 s3cR3t:10 102 s3cR3t:10 103 s3cR3t:10 104 s3cR3t:10 105 s3cR3t:10 106 s3cR3t:10 107 s3cR3t:10 108 s3cR3t:10 109 s3cR3t:10 111 s3cR3t:10 112 s3cR3t:10 113 s3cR3t:10 114 s3cR3t:10 115 s3cR3t:10 116 s3cR3t:10 117 s3cR3t:10 118 s3cR3t:10 119 s3cR3t:10 120 s3cR3t:10 121 s3cR3t:10 134 s3cR3t:10 135 s3cR3t:10 136 s3cR3t:10 137 s3cR3t:10 138 s3cR3t:10 139 s3cR3t:10 140 s3cR3t:10 141 s3cR3t:10 142 s3cR3t:10 143 s3cR3t:10 145 s3cR3t:10 146 s3cR3t:10 147 s3cR3t:10 148 s3cR3t:10 149 s3cR3t:10 150 s3cR3t:10 151 s3cR3t:10 152 s3cR3t:10 153 s3cR3t:10 154 s3cR3t:10 156 s3cR3t:10 157 s3cR3t:10 158 s3cR3t:10 159 s3cR3t:10 160 s3cR3t:10 161 s3cR3t:10 162 s3cR3t:10 163 s3cR3t:10 164 s3cR3t:10 165 s3cR3t:10 190 s3cR3t:10 191 s3cR3t:10 192 s3cR3t:10 193 s3cR3t:10 194 s3cR3t:10 195 s3cR3t:10 196 s3cR3t:10 197 s3cR3t:10 198 s3cR3t:10 199 s3cR3t:10 212 s3cR3t:10 213 s3cR3t:10 214 s3cR3t:10 215 s3cR3t:10 216 s3cR3t:10 217 s3cR3t:10 218 s3cR3t:10 219 s3cR3t:10 220 s3cR3t:10 221 s3cR3t:10 223 s3cR3t:10 224 s3cR3t:10 225 s3cR3t:10 226 s3cR3t:10 227 s3cR3t:10 228 s3cR3t:10 229 s3cR3t:10 230 s3cR3t:10 231 s3cR3t:10 232 s3cR3t:10 233 s3cR3t:10 234 s3cR3t:10 235 s3cR3t:10 236 s3cR3t:10 237 s3cR3t:10 238 s3cR3t:10 239 s3cR3t:10 240 s3cR3t:10 241 s3cR3t:10 242 s3cR3t:10 243 s3cR3t:10 244 s3cR3t:10 246 s3cR3t:10 247 s3cR3t:10 248 s3cR3t:10 249 s3cR3t:10 250 s3cR3t:10 251 s3cR3t:10 252 s3cR3t:10 253 s3cR3t:10 254 s3cR3t:10 255 s3cR3t:10 257 s3cR3t:10 258 s3cR3t:10 259 s3cR3t:10 260 s3cR3t:10 261 s3cR3t:10 262 s3cR3t:10 263 s3cR3t:10 264 s3cR3t:10 265 s3cR3t:10 266 s3cR3t:10 268 s3cR3t:10 269 s3cR3t:10 270 s3cR3t:10 271 s3cR3t:10 272 s3cR3t:10 273 s3cR3t:10 274 s3cR3t:10 275 s3cR3t:10 276 s3cR3t:10 277 s3cR3t:10 279 s3cR3t:10 280 s3cR3t:10 281 s3cR3t:10 282 s3cR3t:10 283 s3cR3t:10 284 s3cR3t:10 285 s3cR3t:10 286 s3cR3t:10 287 s3cR3t:10 288 s3cR3t:10 289 s3cR3t:11 10 and more... 数据量太大就不全部贴出来了. 然后写一下绘图脚本: from PyQt5 import QtGui, QtWidgets, QtCore from PyQt5.QtGui import * from PyQt5.QtCore import * from PyQt5.QtWidgets import * import sys class DrawWidget(QtWidgets.QWidget): def __init__(self, parent=None): super().__init__(parent=parent) self.setStyleSheet('background-color: #ffffff;') def drawPoints(self, qp): qp.setPen(QPen(Qt.black, 2)) with open('./inp.txt', 'r') as inp: data = inp.read().split('s3cR3t:') print(data) for i in data: try: x = int(i.split(' ')[0]) y = int(i.split(' ')[1]) qp.drawPoint(x, y) except: pass def paintEvent(self, QPaintEvent): qp = QPainter() qp.begin(self) self.drawPoints(qp) qp.end() if __name__ == \"__main__\": app = QtWidgets.QApplication(sys.argv) window = DrawWidget() window.show() window.resize(300, 300) app.exec_() 扫码, 解决. ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:8:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"minecraft-2 登陆服务器的时候开着wireshark, 抓包抓到flag2的子服务器地址, 然后改名Ruby, 直连flag2服务器获取flag. ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:8:2","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"Crypto ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:9:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"ιIl 从网上找到一个轮子, 稍加修改使用sage跑一下: # sage h = 31497596336552470100084187834926304075869321337353584228754801815485197854209104578876574798202880445492465226847681886628987815101276129299179423009194336979092146458547058477361338454307308727787100367492619524471399054846173175096003547542362283035506046981301967777510149938655352986115892410982908002343 p = 126982824744410328945797087760338772632266265605499464155168564006938381164343998332297867219509875837758518332737386292044402913405044815273140449332476472286262639891581209911570020757347401235079120185293696746139599783586620242086604902725583996821566303642800016358224555557587702599076109172899781757727 c = 81425203325802096867547935279460713507554656326547202848965764201702208123530941439525435560101593619326780304160780819803407105746324025686271927329740552019112604285594877520543558401049557343346169993751022158349472011774064975266164948244263318723437203684336095564838792724505516573209588002889586264735 v1 = vector(ZZ, [1, h]) v2 = vector(ZZ, [0, p]) m = matrix([[1, h], [0, p]]) shortest_vector = m.LLL()[0] f, g = shortest_vector print(f, g) f = abs(f) g = abs(g) a = f*c % p % g m = a * inverse_mod(f, g) % g print(m) 最终flag: minil{l1Ii5n0tea5y} ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:9:1","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"f**k\u0026base 这道题就是上面那道的变种. 用brainfuck解密一下source.txt: from Crypto.Util.number import * q=getPrime(1024) f=getPrime(511) g=getPrime(511) while g\u003cpow(q/4,0.5) and g\u003epow(q/2,0.5): g=getPrime(511) f_inv_q=inverse(f,q) h=f_inv_q*g%q m=bytes_to_long(b'flag')#flag is base**(flag) r=getPrime(510) e=(r*h+m)%q print f print g print q print e 解密脚本: # sage p = 172620634756442326936446284386446310176482010539257694929884002472846127607264743380697653537447369089693337723649017402105400257863085638725058903969478143249108126132543502414741890867122949021941524916405444824353100158506448429871964258931750339247018885114052623963451658829116065142400435131369957050799 c = 130055004464808383851466991915980644718382040848563991873041960765504627910537316320531719771695727709826775790697704799143461018934672453482988811575574961674813001940313918329737944758875566038617074550624823884742484696611063406222986507537981571075140436761436815079809518206635499600341038593553079293254 f = 4685394431238242086047454699939574117865082734421802876855769683954689809016908045500281898911462887906190042764753834184270447603004244910544167081517863 g = 5326402554595682620065287001809742915798424911036766723537742672943459577709829465021452623299712724999868094408519004699993233519540500859134358256211397 a = f*c % p % g m = a * inverse_mod(f, g) % g print(m) # m = 629250774757584627131327668302148468 ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:9:2","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"做题情况 感谢luoqi@n大哥和arttnba3大哥带我飞~ 虽然只拿了第三, 没有pwn手也没有Web手的情况下也挺不错了hhh~ 作为一个Re手自我感觉良好, 虽然安卓题就写了一道emmm 但Re解题情况应该是参赛组中最好的. ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:10:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["CTF"],"content":"总结 还是要继续学Re啊~ 同时作为一个二进制组员, pwn多多少少也要会… 毕竟CTF中pwn的比重太大了, 全盘放弃实在是伤… ","date":"2020-05-17","objectID":"/posts/minilctf_2020_wp/:11:0","tags":["CTF"],"title":"Mini L CTF WriteUp By Int3rn3t_Expl0rer Team","uri":"/posts/minilctf_2020_wp/"},{"categories":["Development"],"content":"node.js更新到14.2之后, hexo就无法正常使用了. 导致我的博客凉了好久.. 现在写一下我目前的解决方案. ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:0:0","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"错误详情 运行hexo之后报错: Hexo deploy error #4281 $ hexo g -d (node:482144) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency (Use `node --trace-warnings ...` to show where the warning was created) (node:482144) Warning: Accessing non-existent property 'column' of module exports inside circular dependency (node:482144) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency (node:482144) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency (node:482144) Warning: Accessing non-existent property 'column' of module exports inside circular dependency (node:482144) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency INFO Files loaded in 842 ms INFO 0 files generated in 669 ms INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html TypeError [ERR_INVALID_ARG_TYPE]: The \"mode\" argument must be integer. Received an instance of Object at copyFile (fs.js:1890:10) at tryCatcher (/home/reverier/文档/Blog/node_modules/bluebird/js/release/util.js:16:23) at ret (eval at makeNodePromisifiedEval (/usr/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promisify.js:184:12), \u003canonymous\u003e:13:39) at /home/reverier/文档/Blog/node_modules/hexo-fs/lib/fs.js:144:39 at tryCatcher (/home/reverier/文档/Blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:547:31) at Promise._settlePromise (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:604:18) at Promise._settlePromise0 (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:649:10) at Promise._settlePromises (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:729:18) at Promise._fulfill (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:673:18) at Promise._resolveCallback (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:466:57) at Promise._settlePromiseFromHandler (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:559:17) at Promise._settlePromise (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:604:18) at Promise._settlePromise0 (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:649:10) at Promise._settlePromises (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:729:18) at Promise._fulfill (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:673:18) at Promise._resolveCallback (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:466:57) at Promise._settlePromiseFromHandler (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:559:17) at Promise._settlePromise (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:604:18) at Promise._settlePromise0 (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:649:10) at Promise._settlePromises (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:729:18) at Promise._fulfill (/home/reverier/文档/Blog/node_modules/bluebird/js/release/promise.js:673:18) ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:1:0","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"官方回复 @Reverier-Xu @stephen-a2z @dumindu @pwittchen We published v4.2.1. v4.2.1 has included fixed compatible with Node 14. Thanks :) 但是更新到4.2.1之后问题依旧. ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:2:0","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"另觅方法 ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:3:0","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"降级Node.js? $ sudo pacman -U /var/cache/pacman/pkg/nodejs-13.13.0-1-x86_64.pkg.tar.zst 用pacman的缓存降到了13.13版本, 这个方法工作了大概一个星期. 紧接着, Node.js的依赖库更新了… 于是 全 部 木 大 如果我想继续使用降级Node.js, 那我就必须把依赖库都降级, 同时还要降级其它的所有依赖的与被依赖的软件包, 直到官方兼容Node 14.2. 可是, 我这是Arch Linux啊, 降级? 大规模降级? 恐怕等官方修复了之后我再更新, 就滚挂了吧. ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:3:1","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"虚拟机? 尝试在Linux里面开Linux虚拟机竟然只是为了更新博客? 我感觉我脑子还没坏emm ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:3:2","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"docker? docker! 那不如用docker吧. 安装好docker之后获取官方的docker镜像: $ sudo docker pull node:13.14.0-stretch 用以下命令启动docker环境, 并挂载博客目录, 将hexo的服务器端口4000映射到本机的4000: $ sudo docker run -it -p 4000:4000 -v \u003cBlog Location\u003e:/Blog node:13.14.0-stretch /bin/bash 装好依赖, 配置好git的SSH Key, 然后使用sudo docker ps -l查询容器pid, 接着: $ sudo docker commit \u003cpid\u003e node:13.14.0-stretch 保存配置好的环境. 编写一个简单的.desktop文件: [Desktop Entry] Comment= Exec=konsole -e 'sudo docker run -it -p 4000:4000 -v /home/reverier/文档/Blog:/Blog node:13.14.0-stretch /bin/bash' GenericName=Docker Blog Icon= Name=Blog NoDisplay=false Path[$e]= StartupNotify=true Terminal=0 TerminalOptions= Type=Application X-KDE-SubstituteUID=false X-KDE-Username= 扔到~/.local/share/applications目录下面. 写博客还和以前一样, 写好之后点一下这个桌面文件, 输入root密码, 然后和以前一样更新博客就可以了. ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:3:3","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["Development"],"content":"结尾 学了一点简单的docker用法, 感觉还不错呢~ ","date":"2020-05-16","objectID":"/posts/renew_blog_with_docker/:4:0","tags":["Web","Development"],"title":"docker的简单使用 - 博客更新","uri":"/posts/renew_blog_with_docker/"},{"categories":["CTF"],"content":"源代码 出题人编写的源代码如下: #include \u003ccstdlib\u003e #include \u003ccstring\u003e #include \u003ciostream\u003e using namespace std; const char base[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234{}789+/=\"; static char find_pos(char ch) { char *ptr = (char *)strrchr(base, ch); return (ptr - base); } char *RxEncode(const char *data, int data_len) { int ret_len = (data_len / 4) * 3; int equal_count = 0; char *ret = NULL; char *f = NULL; int tmp = 0; int temp = 0; int prepare = 0; int i = 0; if (*(data + data_len - 1) == '=') { equal_count += 1; } if (*(data + data_len - 2) == '=') { equal_count += 1; } if (*(data + data_len - 3) == '=') { // seems impossible equal_count += 1; } switch (equal_count) { case 0: ret_len += 4; // 3 + 1 [1 for NULL] break; case 1: ret_len += 4; // Ceil((6*3)/8)+1 break; case 2: ret_len += 3; // Ceil((6*2)/8)+1 break; case 3: ret_len += 2; // Ceil((6*1)/8)+1 break; } ret = (char *)malloc(ret_len); if (ret == NULL) { printf(\"No enough memory.\\n\"); return nullptr; } memset(ret, 0, ret_len); f = ret; while (tmp \u003c (data_len - equal_count)) { temp = 0; prepare = 0; while (temp \u003c 4) { if (tmp \u003e= (data_len - equal_count)) { break; } prepare = (prepare \u003c\u003c 6) | (find_pos(data[tmp])); temp++; tmp++; } prepare = prepare \u003c\u003c ((4 - temp) * 6); for (i = 0; i \u003c 3; i++) { if (i == temp) { break; } *f = (char)((prepare \u003e\u003e ((2 - i) * 8)) \u0026 0xFF); f++; } } *f = '\\0'; return ret; } int main() { cout \u003c\u003c \"Welcome To Reverier-Encode Program!\" \u003c\u003c endl; cout \u003c\u003c \"Input Your flag:\" \u003c\u003c endl; char flag[] = {-98,-101,-100,-75,-2,112,-45,15,-78,-47,79,-100,2,127,-85,-34,89,101,99,-25,64,-99,-51,-6,4,0,0,0,0,0,0,0,0}; char inp[33]; scanf(\"%33s\", inp); char *result = RxEncode(inp, 33); //for (int i = 0; i \u003c 33; i++){ // cout \u003c\u003c (int)result[i] \u003c\u003c ','; //} if (strlen(inp) != 32) { cout \u003c\u003c strlen(inp) \u003c\u003c endl; cout \u003c\u003c \"Wrong!\" \u003c\u003c endl; return 0; } //result = RxEncode(inp, 33); //for(int i = 0; i \u003c 34; i++){ // cout \u003c\u003c (int) result[i] \u003c\u003c ','; //} if (!strcmp(result, flag)) { cout \u003c\u003c \"Congratulations!\" \u003c\u003c endl; } else cout \u003c\u003c \"Wrong!\" \u003c\u003c endl; return 0; } ","date":"2020-04-28","objectID":"/posts/ha1cyonctf_rxencode/:1:0","tags":["CTF","Reverse"],"title":"Ha1cyon-CTF 你好sao啊 题解","uri":"/posts/ha1cyonctf_rxencode/"},{"categories":["CTF"],"content":"原理 一个换表Base64加密. 这道题将flag当成换表之后的base64子串进行解码, 并将解码之后的数值储存在程序当中. ","date":"2020-04-28","objectID":"/posts/ha1cyonctf_rxencode/:2:0","tags":["CTF","Reverse"],"title":"Ha1cyon-CTF 你好sao啊 题解","uri":"/posts/ha1cyonctf_rxencode/"},{"categories":["CTF"],"content":"解题思路 首先你要看出来IDA里面那个RxEncode的本质是一个换表Base64加密函数, 之后将main里面的数据处理一下然后换表Base64编码即可看见答案. ","date":"2020-04-28","objectID":"/posts/ha1cyonctf_rxencode/:3:0","tags":["CTF","Reverse"],"title":"Ha1cyon-CTF 你好sao啊 题解","uri":"/posts/ha1cyonctf_rxencode/"},{"categories":["CTF"],"content":"源代码 先上源代码: #include \u003cstdio.h\u003e #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; string oOoOo00[35]; char o0ooOo0oo0O[35][42] = { { 84, 84, 24, 89, 84, 56, 12, 47, 87, 56, 4, 47, 84, 0, 50, 47, 84, 84, 16, 36, 87, 0, 46, 46, 84, 17, 12, 23, 45, 38, 92, 92, }, { 84, 19, 8, 48, 84, 19, 8, 48, 84, 16, 8, 9, 84, 86, 46, 42, 84, 45, 16, 38, 84, 86, 16, 12, 84, 0, 87, 0, 45, 46, 92, 92, }, { 84, 17, 8, 7, 84, 87, 12, 87, 84, 45, 8, 45, 84, 19, 54, 35, 84, 19, 54, 16, 84, 84, 16, 36, 84, 45, 83, 6, 45, 41, 92, 92, }, { 84, 45, 20, 47, 84, 85, 50, 83, 84, 87, 4, 56, 84, 0, 74, 38, 84, 84, 16, 36, 87, 45, 4, 5, 84, 87, 0, 86, 45, 32, 92, 92, }, { 84, 19, 8, 17, 84, 3, 16, 12, 84, 19, 0, 40, 84, 0, 50, 25, 84, 84, 16, 36, 84, 84, 87, 18, 87, 59, 4, 81, 45, 41, 92, 92, }, { 84, 17, 4, 6, 84, 19, 46, 55, 87, 42, 4, 12, 84, 17, 38, 85, 84, 84, 16, 36, 84, 17, 8, 46, 84, 0, 50, 17, 45, 39, 92, 92, }, { 84, 19, 42, 9, 84, 17, 24, 43, 84, 3, 24, 55, 84, 56, 16, 3, 84, 84, 16, 36, 84, 45, 8, 54, 84, 84, 54, 44, 45, 38, 92, 92, }, { 84, 19, 42, 9, 84, 17, 24, 43, 87, 40, 50, 0, 84, 56, 83, 22, 84, 84, 16, 36, 84, 56, 54, 43, 84, 3, 12, 81, 45, 37, 92, 92, }, { 87, 45, 74, 56, 84, 59, 24, 14, 84, 87, 83, 43, 84, 84, 83, 32, 84, 45, 83, 6, 84, 56, 4, 87, 84, 85, 87, 22, 45, 41, 92, 92, }, { 84, 17, 4, 13, 84, 17, 4, 13, 84, 0, 50, 2, 84, 0, 50, 2, 87, 40, 4, 16, 87, 45, 83, 18, 84, 84, 16, 36, 87, 42, 38, 44, 84, 17, 8, 7, 45, 36, 92, 92, }, { 84, 56, 8, 22, 84, 0, 50, 36, 87, 56, 38, 20, 84, 19, 20, 9, 84, 56, 8, 19, 84, 45, 16, 87, 84, 84, 16, 36, 87, 40, 46, 44, 84, 3, 83, 25, 45, 38, 92, 92, }, { 87, 42, 87, 17, 87, 0, 46, 46, 84, 59, 34, 84, 84, 17, 54, 11, 84, 19, 4, 82, 84, 45, 12, 25, 84, 84, 16, 36, 84, 59, 38, 89, 84, 59, 34, 85, 45, 38, 92, 92, }, { 84, 3, 74, 19, 84, 3, 74, 19, 84, 19, 8, 39, 87, 56, 0, 50, 7, 15, 92, 92, }, { 87, 59, 83, 59, 87, 59, 83, 59, 84, 85, 54, 15, 84, 45, 16, 20, 84, 56, 87, 7, 84, 17, 83, 13, 84, 84, 16, 36, 87, 40, 4, 16, 84, 3, 4, 25, 45, 45, 92, 92, }, { 84, 0, 50, 17, 84, 87, 12, 87, 84, 19, 50, 50, 84, 19, 20, 9, 84, 3, 74, 88, 84, 85, 50, 83, 84, 84, 16, 36, 84, 56, 54, 43, 84, 17, 8, 46, 45, 36, 92, 92, }, { 84, 84, 24, 89, 84, 45, 8, 21, 84, 56, 74, 16, 87, 42, 0, 35, 84, 86, 20, 0, 84, 85, 46, 34, 84, 84, 16, 36, 84, 0, 50, 17, 87, 59, 12, 39, 45, 38, 92, 92, }, { 84, 56, 0, 47, 87, 0, 46, 4, 87, 42, 38, 44, 40, 54, 92, 92, }, { 84, 14, 8, 51, 84, 56, 20, 41, 84, 17, 54, 8, 84, 59, 24, 22, 84, 14, 16, 18, 87, 45, 54, 82, 84, 0, 50, 81, 45, 44, 92, 92, }, { 84, 84, 24, 45, 84, 84, 83, 32, 87, 40, 24, 19, 87, 40, 24, 19, 84, 84, 16, 36, 84, 0, 87, 41, 84, 0, 87, 59, 45, 41, 92, 92, }, { 84, 0, 50, 0, 84, 3, 34, 51, 84, 17, 24, 16, 84, 84, 74, 13, 84, 84, 16, 36, 84, 17, 8, 7, 84, 84, 34, 37, 45, 43, 92, 92, }, { 84, 17, 24, 43, 84, 19, 42, 9, 84, 17, 24, 43, 87, 56, 34, 0, 84, 59, 34, 51, 84, 17, 24, 16, 84, 17, 83, 13, 87, 45, 4, 23, 84, 56, 74, 11, 45, 37, 92, 92, }, { 84, 45, 16, 24, 84, 85, 8, 25, 84, 84, 16, 36, 84, 45, 24, 59, 84, 45, 24, 81, 45, 35, 92, 92, }, { 87, 42, 87, 17, 84, 14, 8, 51, 84, 45, 20, 18, 84, 45, 8, 32, 87, 45, 54, 82, 84, 85, 42, 84, 84, 85, 4, 37, 45, 38, 92, 92, }, { 84, 56, 20, 41, 84, 19, 34, 52, 84, 59, 42, 44, 84, 45, 74, 9, 84, 3, 74, 80, 45, 46, 92, 92, }, { 84, 59, 24, 14, 87, 56, 38, 13, 87, 45, 74, 2, 84, 84, 16, 36, 84, 0, 50, 17, 87, 45, 87, 84, 45, 38, 92, 92, }, { 87, 59, 46, 83, 84, 19, 42, 27, 87, 45, 87, 84, 84, 86, 24, 56, 45, 41, 92, 92, }, { 84, 17, 24, 43, 84, 45, 8, 32, 84, 85, 12, 41, 84, 87, 54, 4, 84, 0, 54, 41, 84, 84, 16, 36, 84, 3, 83, 17, 87, 43, 12, 84, 84, 19, 54, 82, 45, 34, 92, 92, }, { 84, 59, 42, 44, 84, 14, 8, 51, 84, 45, 8, 32, 87, 45, 54, 82, 84, 56, 0, 50, 87, 59, 12, 17, 45, 35, 92, 92, }, { 87, 0, 46, 4, 84, 59, 34, 51, 84, 56, 74, 12, 84, 45, 8, 32, 84, 45, 8, 16, 84, 45, 8, 54, 84, 84, 54, 44, 45, 34, 92, 92, }, { 84, 59, 24, 14, 87, 56, 38, 13, 87, 45, 74, 2, 84, 84, 16, 36, 84, 0, 50, 17, 87, 45, 87, 84, 45, 35, 92, 92,","date":"2020-04-21","objectID":"/posts/ha1cyonctf_wohu/:1:0","tags":["CTF","Reverse"],"title":"Ha1cyon-CTF 芜湖 题解","uri":"/posts/ha1cyonctf_wohu/"},{"categories":["CTF"],"content":"解题思路 这道题我们用IDA打开之后, 可以看见: main函数里面直接跳转到了这里. 经过查看, 第二层for循环中的判断条件和第一层for循环的i结合起来, 应该是在遍历一个二维数组, 而第二层for中的那个变量数组应该表示二维数组中不同维度的元素的长度. 再往下看, v3就是在提取这个二维数组中的每个元素了. 我们点进这个数组, 可以看到一大片数据. 接下来对v3进行处理, 结果存进v2: for ( k = 0; k \u003c= 7; ++k ) v2 = Oo0O((v3 \u003e\u003e (7 - k)) \u0026 1, (97 \u003e\u003e (7 - k)) \u0026 1) \u0026 1 ^ 2 * v2; 可以看出这是一个按位操作, 而Oo0O()函数有点迷惑. 它里面的长这样: __int64 __fastcall Oo0O(int a1, int a2) { int v2; // eax int v3; // ebx int v4; // eax int v5; // eax _BOOL4 v6; // ebx char v8; // [rsp+1Fh] [rbp-41h] char v9; // [rsp+20h] [rbp-40h] unsigned __int64 v10; // [rsp+48h] [rbp-18h] v10 = __readfsqword(0x28u); std::allocator\u003cchar\u003e::allocator(\u0026v8); std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::basic_string(\u0026v9, \u0026unk_3010, \u0026v8); std::allocator\u003cchar\u003e::~allocator(\u0026v8); v2 = o0o0o(a1, a2); v3 = o0o0o(a1, v2); v4 = o0o0o(a1, a2); v5 = o0o0o(a2, v4); v6 = o0o0o(v5, v3); std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::~basic_string(\u0026v9); return (unsigned int)v6; } 其中又涉及到了o0o0o()函数, 这个函数原型十分简单, 就只有一句话: return (a2 \u0026 a1) == 0; 如果选手对数字电路有些许了解的话, 应该很轻松的可以辨认出, 这个函数是与非门(NAND门). 结合hint, 我们可以大致画出Oo0O()函数的结构: 这个结构走一遍, 实际上就是异或门(xor). 异或大家就很熟悉了. 稍微改一下IDA反编译出来的函数, 我们可以得到一堆Base64字符串. 其实没有学过模电问题也不大, 我们使用gdb, 在o0o0OO()函数前面下个断点, 就像这样: 然后你就可以看见寄存器指向的运算结果了, 继续跟踪, 我们可以把所有经过运算的字符串全部抓出来, 得到了一堆Base64. 这个时候你把Base64全部拿出去解码, 只能得到和程序运行之后的输出一样的一堆歌词, 并没有flag. 我们观察这些歌词的结尾大部分都是逗号, 然后结合hint的提示, 相同字符经过Base64编码后的结果是相同的, 但是你所抓出来的这一大串base64, 他们的结尾甚至都不相同. ,经过编码后是LA==, 但是这些base64结尾不全都是这个. 这个时候你需要对Base64的解码过程有一定的理解, Base64解码过程中会舍弃=所对应的padding位, 这也是Base64隐写的原理. 因此我们把那一堆Base64用隐写提取脚本提取一下就可以了. ICTFE中关于Base64隐写提取的函数如下: def base64_stego(lines): alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' flag = '' temp = 0 digit = 0 for i in lines: if i[-1] != '=': continue elif i[-2] != '=': digit += 2 temp = (temp \u003c\u003c 2) + (alphabet.find(i[-2]) \u0026 0x3) else: digit += 4 temp = (temp \u003c\u003c 4) + (alphabet.find(i[-3]) \u0026 0xf) if digit == 8: digit = 0 flag += chr(temp) temp = 0 elif digit \u003e 8: digit = 2 flag += chr(temp \u003e\u003e 2) temp = temp \u0026 0x3 return flag ","date":"2020-04-21","objectID":"/posts/ha1cyonctf_wohu/:2:0","tags":["CTF","Reverse"],"title":"Ha1cyon-CTF 芜湖 题解","uri":"/posts/ha1cyonctf_wohu/"},{"categories":["Workspace"],"content":"前言 archlinuxcn中有打包好的wine-wechat应用, 但是该应用启动后有边框阴影特效, 此时如果有另一个应用覆盖在微信的窗口之前, 阴影就会被置顶, 从而造成一些视觉阻碍. 像下面这样: 非强迫症还好, 强迫症简直不能忍受. 即使不是强迫症, 这个阴影边框竟然还有调整大小的控件, 对日常使用造成了一定的阻碍. 本文介绍如何关闭这个阴影. 从理论上来说, 所有的出现问题的wine应用都可以应用此办法来解决. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:1:0","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"解决过程 ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:2:0","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"xwininfo和wmctrl的使用 xwininfo是一个窗口查看工具. 我们可以在打开微信的情况下在终端输入xwininfo然后回车, xwininfo会让你用鼠标选取窗口, 然后输出这个窗口的详细信息. 选中阴影后我们可以查看窗口的window id, 在这里是0xae00014: 然后我们运行wmctrl -l -G -p -x来查看当前所有活动的窗口: 通过多次实验, 我发现微信窗口后四位所对应的不同窗口层次是固定的. 主窗口是0xXXXX000a, 那么阴影所对应的窗口就是0xXXXX0014. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:2:1","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"通过xdotool来隐藏阴影窗口 xdotool是一个很方便实用的工具. 我们可以通过它来隐藏某个窗口, 只需要提供window id就可以了. 使用方法如下: $ xdotool windowunmap \u003cwindow-id\u003e 于是我们只要找到wechat.exe的\u003cwindow-id然后用xdotool windowunmap 0xXXXX0014就可以达成我们的目标了. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:2:2","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"编写Python脚本并集成到系统里 有了上面介绍的三个工具, 我们就可以通过写一个简单的小脚本来随着微信的启动而启动, 每五秒检测一次, 然后隐藏wechat的窗口阴影, 检测到wechat退出就自动退出. #!/usr/bin/env python3 import time import os while True: time.sleep(5) exist = os.popen(\"ps -ef | grep WeChat.exe\") e = exist.readlines() if len(e) \u003c 3: print(e) print(\"WeChat not started. Exit...\") exit() output = os.popen(\"wmctrl -l -G -p -x\") s = output.readlines() print(s) id = '' for item in s: if item.find(\"wechat.exe.Wine\") != -1: id = item.split()[0] break output.close() print(id) if id != '': shadow = id[:-4] + \"0014\" print(shadow) os.system(\"xdotool windowunmap \" + shadow) else: print(\"WeChat not display yet.\") 给这个脚本放在一个合适的位置, 加上权限后链接到/bin/disable-wechat-shadow 然后编写启动脚本: #!/bin/sh env WINEDEBUG=-all /bin/wechat \u0026 /bin/disable-wechat-shadow 然后把这个脚本加上执行权限, 链接到/bin/wechat-start. 修改开始菜单中wechat的启动命令.将其改为/bin/wechat-start. 然后再打开微信, 登录后的主窗口阴影过一小会儿就消失了. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:2:3","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"小问题 如果你把wechat给关闭了, 或者最小化了, 它每次恢复窗口的时候都会重新绘制阴影. 所以无奈之下只能在wechat运行期间让脚本定时检测了. 时间间隔不敢设置的太短, 导致总有一小段时间会显示阴影, 不过也就3~4秒, 不耽误使用. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:3:0","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"ToDo 在Limstash的博客:通过 wine 完美运行最新版网易云音乐这篇文章里作者用C++和X11的接口实现了一个简单的窗口劫持, 在启动网易云之后只需要运行一次即可关闭, 不需要一直挂着脚本. 我看到这篇博文之前也写过一个类似的程序, 效果还不如这位大佬的, 就不贴出来了. 在尝试把代码简单的修改来适应微信的阴影关闭时发现这两个程序有一些不一样的地方, 修改后的程序也没法正常运行, 遂作罢. 等再有时间了好好从头撸一个. wine的应用没法和KDE的媒体管理器进行集成, 也就影响到KDE Connect的效果, 在来电话时不能够自动暂停音乐的播放, 也不能通过远程媒体控制器来遥控电脑. 不过这个问题解决起来恐怕就要动大工程了. ","date":"2020-02-16","objectID":"/posts/wine_wechat_shadow_bugs_solution/:4:0","tags":["Linux","Workspace"],"title":"wine-wechat 窗口阴影置顶解决方案","uri":"/posts/wine_wechat_shadow_bugs_solution/"},{"categories":["Workspace"],"content":"前言 自从上次用过Arch Linux滚挂之后, 辗转于Manjaro, Deepin, Fedora, 最后还是趁着没法出门, 在家里把Arch Linux又整上了. 但是安装好TIM之后还是老问题, KDE下面用TIM下载群文件之后没法点击打开文件夹来方便的定位文件. 正好闲着没事干, 就解决一下这个问题. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:1:0","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"过程 ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:2:0","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"查看出错 右键应用程序启动器, 打开编辑应用程序, 找到TIM, 复制启动指令, 然后打开一个终端并粘贴指令, 执行. 这样就可以在打开TIM的时候查看详细的应用程序输出了. 果不其然, 在我下载完测试文件点击打开文件夹的时候提示找不到指令dde-file-manager. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:2:1","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"第一次解决 dde-file-manager是Deepin操作系统的文件管理器, 而在KDE里面文件管理器是dolphin. 于是想办法: $ sudo ln -s /bin/dolphin /bin/dde-file-manager 试图通过给dolphin链接到dde-file-manager来伪造一个Deepin文件管理器, 将使用Deepin文件管理器打开的命令链接到dolphin上来解决. 但是点击链接依然打不开. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:2:2","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"再次查看出错 还是同样的方法, 发现在单击链接之后dolphin报错无效的选项show-item. Google之, 发现深度文件管理器可以通过dde-file-manager --show-item $FilePath的形式来打开路径并高亮选中文件. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:2:3","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"第二次解决 运行dolphin --help: $ dolphin --help Usage: dolphin [options] +[Url] 文件管理器 Options: -h, --help Displays help on commandline options. --help-all Displays help including Qt specific options. -v, --version Displays version information. --author 显示作者信息. --license 显示版权信息. --desktopfile \u003c文件名\u003e 此应用程序的桌面条目的基础文件名 --select 参数中传递的文件和文件夹会被选中。 --split Dolphin 将以拆分视图启动。 --new-window Dolphin 将明确地在新窗口中打开。 --daemon 启动 Dolphin 守护进程 (只在使用 DBus 接口时需要) Arguments: +[Url] 要打开的文档 从参数列表来看只需要把--show-item参数更换成--select参数就可以了. 我选择拿python简单的写几句来实现这个功能. 首先删掉原先的dde-file-manager链接: sudo rm /bin/dde-file-manager 然后想办法让python接受两个参数, 并调换第一个参数. ##!/bin/python3 ## -*- coding: UTF-8 -*- ## 文件名: dde-file-manager.py import sys import os options = sys.argv[1] path = sys.argv[2] os.system(\"dolphin --select \"+'\"'+path+'\"') 简单的替换掉就可以了. 加上执行权限, 扔到$HOME/.local/share目录下面, 然后: $ sudo ln $HOME/.local/share/dde-file-manager.py /bin/dde-file-manager 再然后打开TIM, 接收文件, 点击打开所在文件夹, 就可以非常顺利的用dolphin打开文件夹了. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:2:4","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"结尾 如果网上找不到现有的办法可以解决某些小bug, 就动手自己解决. 通常情况下这些问题并不复杂, 只是大部分人会永远把自己局限在一个新手的层面, 除了Google和百度就不肯自己动手发现问题了. 事实证明, 自己动手, 还是很明智的一个选择. ","date":"2020-02-10","objectID":"/posts/kde_tim_bugs_solution/:3:0","tags":["Linux","Workspace"],"title":"KDE上TIM无法打开文件所在位置的解决方案","uri":"/posts/kde_tim_bugs_solution/"},{"categories":["Workspace"],"content":"前言 请阅读上一篇之后再来读本文哦~ ","date":"2019-11-15","objectID":"/posts/drop_in_arch_1/:1:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅的堕落-2","uri":"/posts/drop_in_arch_1/"},{"categories":["Workspace"],"content":"正文 ","date":"2019-11-15","objectID":"/posts/drop_in_arch_1/:2:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅的堕落-2","uri":"/posts/drop_in_arch_1/"},{"categories":["Workspace"],"content":"基本配置 扩展软件 聊天软件 TIM, 微信是差不多是阻止大批量用户使用Linux的原因之最. 我已经不想再吐槽某鹅厂了, 这里讲一下如何在Linux里面使用TIM和微信. 使用微信十分的简单, 无论是wine版本还是网页版都挺优秀的. 在这里我们使用electronic-wechat, 是基于electron和网页版微信的第三方版本, 用户体验可以说是十分优秀的. ArchLinuxCN源里也有这个软件包: $ sudo pacman -S electronic-wechat TIM使用的是Deepin团队打包的Deepin-wine来运行的Windows版TIM. 10月24日腾讯发布了LinuxQQ 2.0, 但其代码和2008 1.0版的差别并不大, 使用的还是GTK2.0, 在KDE上的兼容性非常不好, 并且有许多已知BUG. 等腾讯真正静下心来做一个说得过去的QQ for Linux, 或许我会去体验一下. ArchLinuxCN源里也有打包好的TIM: sudo pacman -S deepin.com.qq.office 但这样我们在KDE环境下是打不开的, Deepin所打包的TIM是适配GTK风格桌面的. 我们安装gnome-settings-daemon来解决这个问题: sudo pacman -S gnome-settings-daemon 设置/usr/lib/gsd-xsettings为自启动: 系统设置-\u003e开机或关机-\u003e自动启动-\u003e添加脚本-\u003e输入/usr/lib/gsd-xsettings 重启就好了. 媒体播放器 由于简洁的需要, 我们可以装mplayer来播放一些常见的视频. 如果有更多的需求, 可以装VLC播放器. VLC就不多介绍了, 用过的人除了吐槽界面丑之外都说好. 另外, 深度影院也是非常不错的, 在KDE下面可能显示有一点点小问题, 但总体来说使用起来还是很舒服的. 音乐播放器能基本达到Windows体验的只有网易云音乐了, 还有一些挺优秀的本地音乐播放器, 如AMROK, 深度音乐等, 可以按照需求去装. 还有一个叫做ffmpeg的东东, 是堪比Media Encoder的存在, 用来转码十分的方便, 还可以自定义多种需求. $ sudo pacman -S mplayer ffmpeg netease-cloud-music amrok MarkDown 写作软件 其实我习惯装个插件然后用Visual Studio Code来撸markdown, 这样写起来挺方便的. 但是如果习惯Word这种图形化操作的话, 也许一个专用的MarkDown编辑器更适合你. 在这里我们使用Typora, 当然还有Notable, 是一款十分优秀的开源md编辑器, 但是嘛… 我找不到安装的办法. Typora的使用体验挺优秀的, 我没体验过Notable, 不知道会不会更好一些. $ sudo pacman -S typora 办公软件 说实话, Manjaro安装的时候带的OpenOffice和LibreOffice都是很优秀的产品, 但是从Windows过来的用户还真不一定用的习惯… 所以! 我们可以安装WPS的Linux版本. 这是继网易云音乐, 搜狗输入法之后第三个肯在Linux上用心的国产软件! 除了不支持宏操作以外, 其他的使用体验几乎和Windows版本保持了一致. $ sudo pacman -S wps-office PDF Manjaro带的Okular已经十分优秀了… 但我不知道你的版本有没有带… 索性加上: $ sudo pacman -S okular 游戏 Steam 这个不说了, Manjaro出厂带的就有, 几乎畅玩主流游戏, Dota2都可以, 不用我这个菜鸡带大家逛steam了吧 : ) Minecraft Minecraft! 作为一名光荣的方块人, 怎么能不想办法玩MC? 其实不费什么功夫, 你把Windows上MC里的.minecraft文件夹复制过来就行了. 对了, 你在Linux下面看不见.开头的文件夹… 按Ctrl+H就可以看见隐藏文件夹了. 然后去网上找一个HMCL.jar, 和.minecraft放在同一个文件夹下面, 然后在终端里进入这个文件夹, 输入 $ java -jar HMCL.jar 就可以啦! 但是这么弄还是有点麻烦.. 我们在这个文件夹里建一个脚本: $ touch ./start.sh $ vim ./start.sh start.sh ##!/bin/bash java -jar ./HMCL.jar 然后保存退出vim, 继续: $ chmod a+x ./start.sh 然后在文件夹里一点就开啦! 你也可以拖动到桌面上, 然后选择链接到此处, 也可以链接到Latte-dock里. 开发套件 按需安装就好了, 个人力荐Jetbrains全家桶. ","date":"2019-11-15","objectID":"/posts/drop_in_arch_1/:2:1","tags":["Linux","Workspace"],"title":"如何在Linux上优雅的堕落-2","uri":"/posts/drop_in_arch_1/"},{"categories":["Workspace"],"content":"高级配置 我们配置好了所需的软件, 接下来弄一些能显著改善用户体验的东东. 触摸板手势 Linux下面原本是没有触摸板手势这一说的. 那怎么能行呢? OS X那么受到程序员喜爱的原因之一不就是强大的触控板手势么? 所以我们一定要在Linux上实现这个功能. Linux上最容易的实现莫过于Fusuma, 但是我折腾了一会儿发现在KDE上的表现确实很差很差. 最后选择了libinput-gestures来实现, 效果非常好. 我是按照kde5与archlinux环境下配置libinput-gestures多手势操作这篇文章来配置的, 事实证明十分好用. 我就不重新把这篇文章抄一遍了, 只是把我的配置贴出来供大家参考一下. $HOME/.config/libinput-gestures.conf ## 四指右滑切换到右侧的虚拟桌面 gesture swipe right 4 xdotool key ctrl+F1 ## 四指左滑切换到左侧的虚拟桌面 gesture swipe left 4 xdotool key ctrl+F2 ## 在这里我把键位映射改变了一下, 可以去设置里面将切换虚拟桌面 ##的快捷键改为上方的快捷键 ## 三指下滑查看所有任务 gesture swipe down 3 xdotool key ctrl+F9 ## 四指下滑最小化当前窗口 gesture swipe down 4 xdotool key super+alt+m ## 三指上滑打开应用程序面板 ( 开始菜单 ) gesture swipe up 3 xdotool key super+space ## 三指左右滑动快速切换不同的窗口 gesture swipe right 3 xdotool key alt+shift+Tab gesture swipe left 3 xdotool key alt+Tab gesture pinch in 2 xdotool key ctrl+minus # 2指捏: 缩小 gesture pinch out 2 xdotool key ctrl+plus # 2指张: 放大 ## 事实证明这个放大缩小由于是模拟快捷键操作, 所以并不好用, 也并不流畅 ## 但有总比没有好.. ## 四指上滑立体显示所有桌面 gesture swipe up 4 xdotool key ctrl+F11 ","date":"2019-11-15","objectID":"/posts/drop_in_arch_1/:2:2","tags":["Linux","Workspace"],"title":"如何在Linux上优雅的堕落-2","uri":"/posts/drop_in_arch_1/"},{"categories":["Workspace"],"content":"尾语 感觉应该差不多了, 剩下的自己折腾就好了. 加油啦! ","date":"2019-11-15","objectID":"/posts/drop_in_arch_1/:3:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅的堕落-2","uri":"/posts/drop_in_arch_1/"},{"categories":["Workspace"],"content":"前言 为什么折腾了这么久Linux, 才想起来整一个博文呢? emmmm因为老是崩盘嘛… 导致我每次重新配置环境都要想半天, 我之前那个软件是怎么装上的. 后来实在受不了, 索性抛弃了Arch转向了稍微友好一点的Manjaro. 于是我决定写一篇博文, 免得Manjaro哪天抽风了又要忙活好久. 不过还是得感叹一下Manjaro的稳定性. 小更新: 又换回Arch Linux了hhhh. Manjaro虽然好, 但是有些地方还是自己手动配置比较舒服. ","date":"2019-11-02","objectID":"/posts/drop_in_arch_0/:1:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅地堕落-1","uri":"/posts/drop_in_arch_0/"},{"categories":["Workspace"],"content":"正文 ","date":"2019-11-02","objectID":"/posts/drop_in_arch_0/:2:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅地堕落-1","uri":"/posts/drop_in_arch_0/"},{"categories":["Workspace"],"content":"安装 由于某些软件和游戏的原因, 暂时还是脱离不了Windows的怀抱. 虚拟机的体验太差了, 于是经过多方面考虑, 最终决定采用双系统的办法. 首先在Windows上用自带的磁盘管理或者其他的分区工具找好地方, 开辟一个100GB左右的空间出来, 然后从镜像站嫖来最新版的Snapshot镜像, 用Ultra ISO以RAW的格式写进一个空间足够大的U盘里, 开机从U盘启动, 安装过程一切顺利. UEFI的启动方式需要把硬盘上第一个FAT32分区挂载到/boot/efi上, 千万不要手抖选择格式化, 否则你就要失去亲爱的Windows了. 其他的设置无需多说了, Office套件我选择的是Libre Office, 毕竟从现在来说这个发行版是最稳定的, 没有其他一些奇奇怪怪的问题, 同时也比Open Office颜值高那么一点. 桌面环境当然首选KDE啊, 使用不习惯Gnome的操作逻辑. 并且既然是要配置一个自己舒服的桌面环境, 高度可配置的KDE当然是第一选择. ","date":"2019-11-02","objectID":"/posts/drop_in_arch_0/:2:1","tags":["Linux","Workspace"],"title":"如何在Linux上优雅地堕落-1","uri":"/posts/drop_in_arch_0/"},{"categories":["Workspace"],"content":"基本配置 软件源 因为校内网有镜像站, 所以需要修改一下软件源, 这样就可以很方便的安装软件, 进行后面的配置. $ sudo vi /etc/pacman.d/mirrorlist 在最上面按照格式添加学校的镜像站, 然后打开/etc/pacman.conf添加Archlinuxcn源: [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后执行 $ sudo pacman -Syy 来刷新软件源缓存, 然后 $ sudo pacman -Syu 来将系统更新到最新的版本. 网络加速 因为配置过程中需要大量使用GitHub, 所以我们修改一下/etc/hosts文件, 以更快的从GitHub下载软件. $ sudo nano /etc/hosts 然后用dig或者nslookup指令找出GitHub相关域名的IP地址. 2019年11月3日可用的IP如下: ## GitHub Start 192.30.253.112 github.com 192.30.253.119 gist.github.com 185.199.108.153 assets-cdn.github.com 151.101.128.133 raw.githubusercontent.com 151.101.128.133 gist.githubusercontent.com 151.101.128.133 cloud.githubusercontent.com 151.101.128.133 camo.githubusercontent.com 151.101.128.133 avatars0.githubusercontent.com 151.101.128.133 avatars1.githubusercontent.com 151.101.128.133 avatars2.githubusercontent.com 151.101.128.133 avatars3.githubusercontent.com 151.101.128.133 avatars4.githubusercontent.com 151.101.128.133 avatars5.githubusercontent.com 151.101.128.133 avatars6.githubusercontent.com 151.101.128.133 avatars7.githubusercontent.com 151.101.128.133 avatars8.githubusercontent.com ## GitHub End 当然啦, 我可不保证你看到这篇文章的时候这个还管用. 所以找一份最新的, 或者自己用工具找到相关IP才是正确的做法. 基本软件 开发环境 这里的开发环境指的是各种语言的编译环境. 使用以下指令安装几个比较常见的编译工具: $ sudo pacman -S gcc clang python python2 java可以用 yay jdk 来选择自己想用的版本. 博主用的是openjdk1.8.0, 因为Minecraft可以用这个版本跑起来 ( 手动狗头 ) Shell: Fish 对, 你没有看错, 这是一条鱼. 笔者的Shell使用本来受到Arch Linux的习惯影响, 是使用zsh作为自己的Shell的, 但是经过Konge学长的推荐, 尝试了这个号称宇宙第一Shell的Fish. 果不其然, 用户体验良好, 准备常驻了. 要安装Fish, 只需要: $ sudo pacman -S fish 然后在终端里输入fish就可以进入然后开启快乐旅程了. 我们把fish设为默认的Shell. 首先打开Konsole的配置方案管理, 编辑配置方案, 启动命令从/bin/bash换成/bin/fish. 接着重启Konsole. 然后把用户的默认shell也换成fish: $ sudo chsh -s /usr/bin/fish root $ sudo chsh -s /usr/bin/fish [username] fish每次启动时都会有打招呼内容, 我们用以下命令来自定义这句话: $ set fish_greeting 'Your Greeting Words' 对fish进行配置是十分人性化的, 只需要输入fish_config就可以了, 然后fish会打开本地的一个端口并启动浏览器, 以可视化的方式呈现出fish的各项配置. 功能设置十分的详细. 按照自己的喜好调整好就可了. 包管理器: yay 要充分发挥Arch系Linux的强大之处, 没有AUR怎么能行呢? 所以我们安装yay作为辅助pacman的包管理器. $ sudo pacman -S yay 今后安装软件如果不清楚名称, 就可以 $ yay [Package Name] 来进行搜索, 然后很方便的安装了. 终端编辑器: Vim $ sudo pacman -S vim 即可安装vim. 我大概不用介绍vim了吧… 这可是一个很知名的编辑器呀. 为了让vim更加的好用, 我们可以使用SpaceVim来改善自己的用户体验. 如何安装请参照官网使用指南, 在此不再赘述. 浏览器: Chrome $ sudo pacman -S google-chrome 用Chrome完全是笔者的个人习惯, Manjaro自带的FireFox十分的优秀, 如果对浏览器没什么习惯的用FireFox完全可以. GUI代码编辑器: Visual Studio Code 经过微软的开源和诸多开发者的贡献之后, Visual Studio Code现在已经无愧于最强代码编辑器的称号了. (当然, 博主并不是在这里引战, 如果你非要用Sublime或者Atom也莫得关系) ArchlinuxCN源中有vscode的二进制版. $ sudo pacman -S visual-studio-code-bin 装好之后打开插件搜索chinese装一下中文包, 英语超级优秀的同学请忽略此句. 我一般会对VSCode进行一点小配置, 然后装一些插件. 这里推荐使用Fira Code作为字体并开启字体连字, 某些符号看起来真的无比舒服. 还有一些插件, 博主大一学习, 装的插件有C/C++, Red Hat提供的java扩展, python, intellicode, LeetCode, DailyAnime和VSC Netease music. 扩展软件 下拉式终端: Tilda 本来Manjaro是自带了一个Yakuake下拉式终端, 但是我实在是用不习惯, 并且它的显示有时候会出些问题. 因此我卸载了Yakuake装了Tilda. 打开设置, 在设置 \u003e 开机和关机 \u003e 自动启动里添加启动项, 并选择应用程序, 输入Tilda并开启. 在桌面上直接敲Tilda, 可以从KDE的快速启动器中启动Tilda. 启动后我们可以进行一些设置, 比如透明度, 颜色, 启动命令, 延迟, 自动隐藏规则等等. 应用程序启动器: Latte-Dock 虽然我没有用过Mac OS X, 但是对其高效的桌面念念不忘. 同时我又想节省一下空间, Windows下面, 厚重的任务栏就占去了一部分屏幕, 标题栏又削一层, 菜单栏又削一层… 最后留给应用程序的显示空间就少了不必要的一部分. 于是我想找到一种办法, 把菜单, 标题, 状态栏集中在一个bar上面, 任务栏没办法, 要保证同时可用性, 就只能弄一个dock当任务栏, 在窗口活动时自动隐藏了. Latte Dock原生和KDE集成在一起, 通过它可以享受很棒的dock. $ sudo pacman -S latte-dock 按照和tilda同样的方法把latte-dock也设置为自动启动, 然后在快速启动器里面输入latte并回车, 就可以看见dock了. 然后把任务栏拖动到屏幕上方, 右键任务栏配置面板, 把开始菜单和任务管理器, 虚拟桌面都删掉, 留下显示桌面和状态栏即可. 然后在面板左侧添加空白. 然后添加控件, 选择全屏的应用程序启动面板, 并拖动到Latte-Dock的第一个位置. Latte-Dock的默认隐藏策略就很智能, 无需单独配置. 在添加控件的侧栏下方安装新控件, 搜索Application Title并安装, 然后配置任务栏那一行, 拖动全局菜单到最左侧, 旁边插入空白, 再插入Application Title, 再插入空白, 最后是状态栏等控件. 最后我们想办法, 把最大化窗口的标题栏去掉. 在./.config/kwinrc中找到[Windows]的选项, 然后按照以下方式配置: [Windows] BorderlessMaximizedWindows=true ElectricBorderCooldown=350 ElectricBorderCornerRatio=0.25 ElectricBorderDelay=150 ElectricBorderMaximize=true ElectricBorderTiling=true ElectricBorders=1 RollOverDesktops=true 配置完成后的效果大概如图所示. 输入法: Fcitx-pinyin 作为中国人, 配置了这么久才发现自己连中文输入都不能… 那怎么能行, 当然要装一下中文输入法了. $ sudo ","date":"2019-11-02","objectID":"/posts/drop_in_arch_0/:2:2","tags":["Linux","Workspace"],"title":"如何在Linux上优雅地堕落-1","uri":"/posts/drop_in_arch_0/"},{"categories":["Workspace"],"content":"安装Arch系统可以参考 ","date":"2019-11-02","objectID":"/posts/drop_in_arch_0/:3:0","tags":["Linux","Workspace"],"title":"如何在Linux上优雅地堕落-1","uri":"/posts/drop_in_arch_0/"},{"categories":["Algorithms"],"content":"前言 本来什么都不会的, 但是呢, 为了能顺利进入MSC in XDU去打ACM, 我就只能硬着头皮上啦… ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:1:0","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"网络流是什么 ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:2:0","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"通俗的解释 什么是网络流呢??? 某升专门去Google学术搜索了一下, 然后发现我什么也看不懂… 无奈翻出紫书开始研究, 用一个通俗的方式讲, 就是一张地图,许多城市, 不同城市间有道路, 但是为了防止事故, 都是单行道. 这些道路各有宽窄, 宽的路自然就运的东西多啦… 各个道路组成了一张道路交通网, 我们可以将其抽象化为网络这个词. 而网络流里面的流, 指的就是车辆运输的东西啦 ( 溜 ). 一条路所能承载的最大运输量, 称之为流量. 这大概就解释了一个十分清晰的网络流模型了… ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:2:1","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"最大流问题 ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:3:0","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"通俗的解释 现在, 假设某升有天发达了在A市开了个仓库, 现在某升希望从A市向很远的B市运输东西, 但是呢, 每跑一次都要花费大量的人力物力, 所以需要找到一条路, 使得从A市到B市的一次运输能尽可能多的带东西过去.. 现在需要找到一条道路, 并求出理论上能运输的物品的最大数量… 第一次看这种问题感觉似乎不是很难? 广度优先搜索应该可以搞定吧 ( 汗 )… ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:3:1","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"概念 我们可以画一张简单的图: 这张粗陋的图简单的写了一下刚刚某升运货的情况… 从A市到B市间隔了V1~V4四座城市, 某升可以在这里稍作停留. 问走哪条路才是最佳的选择呢? 在这张图里, 对于一条道路(u, v), 我们把它的运输上限称为容量(Capacity), 记为c(u, v), 把实际能运送的物品叫做流量(Flow), 记为f(u, v). 我们还可以发现A只出不进, B只进不出, 而其他的节点都会有进出. 在问题之中, 应当明确, 当运输任务完成时, A的输出量就是B的输入量 ( 否则某升就亏大了.. ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:3:2","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"增广路算法 ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:4:0","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"介绍 既然了解了这个问题, 就得想办法去解决它… 怎么解决呢? 这里有一种叫做增广路算法的东西.. 具体做法, 就是先建一个空图, 然后从零流量开始, 不断地增加流量, 保证每次增加之后都满足对于每条路: f(u, v) == -f(v, u), 每条路上的流量不超过路容量, 以及A市输出和B市输入是一致的. 这三个特性分别称为 斜对称性, 容量限制, 流量平衡. 我们把每条边上的容量和流量之差称之为残量, 就是残余容量的意思, 这样的话残量网络就会多出几条返回的道路. 现在我们可以发现一个惊人的事实: 残量网络中任何一条从A市到B市的道路都对应原来网络中一条增广路—意思就是只要求出所有可行道路中的最小残量d , 把所有边上的流量增加d即可. 这个过程就叫增广! 只要残量网络中存在增广路, 那么流量就有继续增大的方法; 当然, 如果不存在增广路了, 那么就说明我们的算法达成目的了! ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:4:1","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["Algorithms"],"content":"代码 好了, 了解了这么多, 我怎么写这个代码呢? 最先想到的毫无疑问是DFS啦… 找路径用DFS还不快? 但是…想不出来DFS写出来的代码应该怎么去增流和维护… 这样一来, 就算实现了, 似乎也很容易爆时间… 那我们换种方法.. 通过紫书上说的, 有种基于BFS的Edmonds-Karp算法, 对付数据不刁钻的题目很好用.. 等我把代码抄一遍… ##include \u003ccstring\u003e ##include \u003calgorithm\u003e ##include \u003ciostream\u003e using namespace std; const int INF = 0x7f7f7f7f; int dis[2001], // 流量 head[2001], nxt[600001], // 邻接表存储 before[600001], value[600001], // 路的容量 S, T, // 源和汇 num[501], // 存储输入数组 n, k = 1, // n是用来存储数组长度的 flow[501]; // f用来存储流 int q[2001], h, t, p[2001], maxlen; void push(int from, int to, int val) { k++; // 递增边的数量 nxt[k] = head[from]; // 然后设置 head[from] = k; before[k] = to; value[k] = val; } void link(int from, int to, int value) { push(from, to, value); // 正向建路 push(to, from, 0); // 反向建路, 这样以后回退起来计算着很方便 } bool bfs() { memset(dis, 0, sizeof dis); // 首先初始化distance dis[S] = 1; h = t = 0; q[++t] = S; while (h \u003c t) { ++h; for (int i = head[q[h]]; i; i = nxt[i]) if (value[i] \u0026\u0026 !dis[before[i]]) { dis[before[i]] = dis[q[h]] + 1; q[++t] = before[i]; if (before[i] == T) return 1; } } return 0; } int dfs(int x, int flow) { if (x == T || !flow) return flow; int used = 0; for (int i = p[x]; i; i = nxt[i]) if (value[i] \u0026\u0026 dis[before[i]] == dis[x] + 1) { int w = dfs(before[i], min(flow - used, value[i])); value[i] -= w; value[i ^ 1] += w; used += w; if (w) p[x] = i; if (used == flow) return used; } if (!used) dis[x] = 0; return used; } int main() { cin \u003e\u003e n; S = 0, T = n * 2 + 1; // 把汇设置成了两倍加一 for (int i = 1; i \u003c= n; i++) cin \u003e\u003e num[i]; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c i; j++) if (num[j] \u003c= num[i] \u0026\u0026 flow[j] \u003e flow[i]) flow[i] = flow[j]; flow[i]++; maxlen = max(maxlen, flow[i]); } // 建流 //接下来使用上述介绍的方法建图 cout \u003c\u003c maxlen \u003c\u003c endl; for (int i = 1; i \u003c= n; i++) link(i, i + n, 1); for (int i = 1; i \u003c= n; i++) if (flow[i] == 1) link(S, i, 1); for (int i = 1; i \u003c= n; i++) if (flow[i] == maxlen) link(i + n, T, 1); for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c i; j++) if (num[j] \u003c= num[i] \u0026\u0026 flow[j] == flow[i] - 1) link(j + n, i, 1); // 建图完毕 int ans = 0; while (bfs()) { memcpy(p, head, sizeof(p)); ans += dfs(S, INF); } cout \u003c\u003c ans \u003c\u003c endl; link(1, 1 + n, INF), link(S, 1, INF); if (flow[n] == maxlen) link(n + n, T, INF), link(n, n * 2, INF); while (bfs()) { memcpy(p, head, sizeof(p)); ans += dfs(S, INF); } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2019-09-20","objectID":"/posts/leaning_network_algorithm/:4:2","tags":["Algorithms"],"title":"网络流学习1--最大流问题","uri":"/posts/leaning_network_algorithm/"},{"categories":["CTF"],"content":"题目 得, 不多说了, 看图吧… ","date":"2019-09-18","objectID":"/posts/for_shit_http_headers/:1:0","tags":["CTF","Web"],"title":"记一次终极狗屎的HTTP请求头","uri":"/posts/for_shit_http_headers/"},{"categories":["CTF"],"content":"做题过程 rever@DS-10001-RX MINGW64 ~ $ curl --header \"Referer: www.xidian.edu.cn\" -v -i http://39.108.11.206:10012/ * Trying 39.108.11.206... * TCP_NODELAY set % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0*Connected to 39.108.11.206 (39.108.11.206) port 10012 (#0) \u003e GET / HTTP/1.1 \u003e Host: 39.108.11.206:10012 \u003e User-Agent: curl/7.60.0 \u003e Accept: */* \u003e Referer: www.xidian.edu.cn \u003e \u003c HTTP/1.1 200 OK \u003c Date: Fri, 06 Sep 2019 13:25:31 GMT \u003c Server: Apache/2.4.7 (Ubuntu) \u003c X-Powered-By: PHP/5.5.9-1ubuntu4.14 \u003c Vary: Accept-Encoding \u003c Content-Length: 96 \u003c Content-Type: text/html \u003c { [96 bytes data] 100 96 100 96 0 0 680 0 --:--:-- --:--:-- --:--:-- 680HTTP/1.1 200 OK Date: Fri, 06 Sep 2019 13:25:31 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.14 Vary: Accept-Encoding Content-Length: 96 Content-Type: text/html First of all, you must come from XiDian University\u003cbr\u003eSecond, you have to use moectf_browser\u003cbr\u003e * Connection #0 to host 39.108.11.206 left intact rever@DS-10001-RX MINGW64 ~ $ curl --header \"Referer: www.xidian.edu.cn\" --header \"User-Agent: moectf_broswer (Windows NT 10.0; Win64; x64; rv:69.0)\" -v -i http://39.108.11.206:10012/ * Trying 39.108.11.206... * TCP_NODELAY set % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0*Connected to 39.108.11.206 (39.108.11.206) port 10012 (#0) \u003e GET / HTTP/1.1 \u003e Host: 39.108.11.206:10012 \u003e Accept: */* \u003e Referer: www.xidian.edu.cn \u003e User-Agent: moectf_broswer (Windows NT 10.0; Win64; x64; rv:69.0) \u003e \u003c HTTP/1.1 200 OK \u003c Date: Fri, 06 Sep 2019 13:33:44 GMT \u003c Server: Apache/2.4.7 (Ubuntu) \u003c X-Powered-By: PHP/5.5.9-1ubuntu4.14 \u003c Vary: Accept-Encoding \u003c Content-Length: 96 \u003c Content-Type: text/html \u003c { [96 bytes data] 100 96 100 96 0 0 615 0 --:--:-- --:--:-- --:--:-- 615HTTP/1.1 200 OK Date: Fri, 06 Sep 2019 13:33:44 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.14 Vary: Accept-Encoding Content-Length: 96 Content-Type: text/html First of all, you must come from XiDian University\u003cbr\u003eSecond, you have to use moectf_browser\u003cbr\u003e * Connection #0 to host 39.108.11.206 left intact rever@DS-10001-RX MINGW64 ~ $ curl --header \"Referer: www.xidian.edu.cn\" --header \"User-Agent: moectf_broswer\" -v -i http://39.108.11.206:10012/ * Trying 39.108.11.206... * TCP_NODELAY set % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0*Connected to 39.108.11.206 (39.108.11.206) port 10012 (#0) \u003e GET / HTTP/1.1 \u003e Host: 39.108.11.206:10012 \u003e Accept: */* \u003e Referer: www.xidian.edu.cn \u003e User-Agent: moectf_broswer \u003e \u003c HTTP/1.1 200 OK \u003c Date: Fri, 06 Sep 2019 13:34:00 GMT \u003c Server: Apache/2.4.7 (Ubuntu) \u003c X-Powered-By: PHP/5.5.9-1ubuntu4.14 \u003c Vary: Accept-Encoding \u003c Content-Length: 96 \u003c Content-Type: text/html \u003c { [96 bytes data] 100 96 100 96 0 0 615 0 --:--:-- --:--:-- --:--:-- 615HTTP/1.1 200 OK Date: Fri, 06 Sep 2019 13:34:00 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.14 Vary: Accept-Encoding Content-Length: 96 Content-Type: text/html First of all, you must come from XiDian University\u003cbr\u003eSecond, you have to use moectf_browser\u003cbr\u003e * Connection #0 to host 39.108.11.206 left intact rever@DS-10001-RX MINGW64 ~ $ curl --header \"Referer: www.xidian.edu.cn\" --header \"User-Agent: moectf_browser\" -v -i http://39.108.11.206:10012/ * Trying 39.108.11.206... * TCP_NODELAY set % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0*Connected to 39.108.11.206 (39.108.11.206) port 10012 (#0) \u003e GET / HTTP/1.1 \u003e Host: 39.108.11.206:10012 \u003e Accept: */* \u003e Referer: www.xidian.edu.cn \u003e User-Agent: moectf_browser \u003e \u003c HTTP/1.1 200 OK \u003c Date: Fri, 06 Sep 2019 13:35:11 GMT \u003c Server: Apache/2.4.7 (Ubuntu) \u003c X-Powered-By: PHP","date":"2019-09-18","objectID":"/posts/for_shit_http_headers/:2:0","tags":["CTF","Web"],"title":"记一次终极狗屎的HTTP请求头","uri":"/posts/for_shit_http_headers/"},{"categories":["CTF"],"content":"备注 来自MoeCTF 2019 为什么不把这个东东写进题解里呢? 因为我觉得有必要纪念一下… 因为我做完这题, 看见flag里那个preseverance, 我差点把键盘摔了…… 得… 心疼键盘… 不舍得摔… 进了协会摔出题人好了 : ) 更新: 然鹅并不敢 ( ","date":"2019-09-18","objectID":"/posts/for_shit_http_headers/:3:0","tags":["CTF","Web"],"title":"记一次终极狗屎的HTTP请求头","uri":"/posts/for_shit_http_headers/"},{"categories":["CTF"],"content":"前言 好了,本蒟蒻要开始写题解了… 比赛结束力! 题解 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:0:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Sign In ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:1:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"你是西电新生吗? 签到题, 加入考试群, 在公告里面就可以发现flag, 复制, 提交, 一百分到手~ ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:1:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Reverse ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Introducing RE 这道题… 就是教你怎么用IDA的.. 在网上找来的IDA资源, ,然后安装,打开,发现了这么几句: mov dword ptr [esp], offset aWelcomeToTheMo ; \"Welcome to the MoeCTF!\"\rcall puts\rmov dword ptr [esp+17h], 63656F6Dh\rmov dword ptr [esp+1Bh], 447B6674h\rmov dword ptr [esp+1Fh], 6F595F30h\rmov dword ptr [esp+23h], 326B5F75h\rmov dword ptr [esp+27h], 495F776Fh\rmov dword ptr [esp+2Bh], 7D3F4144h\rmov byte ptr [esp+2Fh], 0\rlea eax, [esp+30h+var_19]\rmov [esp], eax ; char *\rcall sub_401500 然后找了个16进制转ASCII的网站, 复制第三行的 63 65 6F 6D 进去, 发现解出来是 ceom 啊嘞?反过来不就是 moec 么? 按照这个思路, 挨个复制然后反过来输出, 就把 flag 找到了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Moe RE 这道题我本来是第二题做的,, 后来发现竟然比我想象中的难… 下载了re, 发现打不开, 就扔进Windows的Linux子系统里, 发现依旧打不开, 啊嘞? 什么情况? 不行我重启到Arch Linux试试? 算了我懒得费那个神… 直接扔进IDA, 发现汇编读不懂, 就按了下F5, 得到了以下伪代码: int __cdecl main(int argc, const char **argv, const char **envp) { // 注释是后来自己添加的 int v3; // eax int result; // eax int j; // [rsp+10h] [rbp-A0h] int i; // [rsp+14h] [rbp-9Ch] int v7; // [rsp+18h] [rbp-98h] __int64 v8; // [rsp+20h] [rbp-90h] char v9[104]; // [rsp+40h] [rbp-70h] __int64 v10; // [rsp+A8h] [rbp-8h] scanf(\"%s\", v9, envp); // 获取输入 v9 v3 = strlen(v9); // 获取输入长度 v7 = v3; // 现在v3 == v7,都是长度 strcpy((char *)\u0026v8, \"abcdefghijklmnopqrstuvwxyz\"); // v8 好像是个 table for ( i = 0; i \u003c v3; ++i ) //遍历输入, 然后把v9里每个字符和table的第i个字符进行异或运算... v9[i] ^= *((_BYTE *)\u0026v8 + i % 26); //*((_BYTE ... % 26)这句就相当于v8[i % 26] for ( j = 0; j \u003c v7; ++j ) //输出v9里各个字符的数字 printf(\"%d,\", (unsigned int)v9[j]); result = 0; if ( __stack_chk_guard == v10 ) result = 0; return result; } 小小的研究一下源代码, 发现是个简单的算法, 具体如代码注释里写的那样, 于是写一个小程序破解之: ##include \u003ciostream\u003e ##include \u003ccstdio\u003e using namespace std; int main() { int x; int i = 0; char v[27] = \"abcdefghijklmnopqrstuvwxyz\"; while (scanf(\"%d,\", x)) { char result = int(v[i % 26]) ^ x; cout \u003c\u003c result \u003c\u003c endl; i++; } } 差不多就是把题目反着写了一遍, 然后运行, 把题目给的数字串输入进去,回车出flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":".pyc 啊嘞? Python难道不是解释型语言么??? ( 我见识太少了 [ 抱头痛哭 ] 按照Bing上搜到的说法, 我就先装了个反编译tool: $ pip install uncompyle 然后… $ uncompyle6 ./test.cpython-37.pyc \u003e ./test.cpython-37.py 再然后就得到了以下代码, 官方说uncompyle只支持Python2.x, 所以搞出来的有bug, 不过差不多能理解: # uncompyle6 version 3.4.0 # Python bytecode 3.7 (3394) # Decompiled from: Python 3.7.4 (tags/v3.7.4:e09359112e, Jul 8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] # Embedded file name: test.py # Size of source mod 2**32: 294 bytes from binascii import b2a_hex from base64 import b32encode x = input y = print if b2a_hex(b32encode(x().encode())).decode() == '4e5658574b5933554d5a3558413452544d4d59473234444a4e525557345a5a4e4b4234574758334447525846364d44514f51595732324c324d55575647344254474e5348323d3d3d': y('congrats') # okay decompiling C:\\\\users\\rever\\Downloads\\test.cpython-37.pyc 看见了一大串hex, 于是找了个网站转换之: NVXWKY3UMZ5XA4RTMMYG24DJNRUW4ZZNKB4WGX3DGRXF6MDQOQYW22L2MUWVG4BTGNSH2=== 根据源代码, 这是一份base32加密的玩意儿, 于是再找个网站解密得到flag: moectf{pr3c0mpiling-Pyc_c4n_0pt1mize-Sp33d} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:3","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy Shell 这个我说什么好咧.. 就是百度找了个upx tool,然后把题上给的exe扔了进去, 再把吐出来的东西扔进IDA… 发现这么一段: mov dword ptr [esp], offset aWelcomeToTheMo ; \"Welcome to the MoeCTF!\"\rcall puts\rmov dword ptr [esp+11h], 63656F6Dh\rmov dword ptr [esp+15h], 757B6674h\rmov dword ptr [esp+19h], 315F7870h\rmov dword ptr [esp+1Dh], 5F615F73h\rmov dword ptr [esp+21h], 646E314Bh\rmov dword ptr [esp+25h], 5F46305Fh\rmov dword ptr [esp+29h], 31326873h\rmov word ptr [esp+2Dh], 7D4Ch\rmov byte ptr [esp+2Fh], 0\rlea eax, [esp+30h+var_1F] 看到那个63 65 6F 6D我就明白了, 和IntroducingRE相同解法, 得到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:4","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy Debugger 这题是告诉你怎么用调试器的… 我懒, 就扔进Visual Studio开了个调试, 然后flag就自己蹦出来了… 没什么技术含量, 对吧… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:5","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy Go 从这题开始, 我知道了, 所有写着Easy的题, 都是骗人的🙂一点都不Easy… 可能我菜是很大的原因吧…… 还是相同的套路, 下载后扔进IDA, 然后看见了浩如烟海的函数… ( woc要不要这么刺激 费尽千辛万苦找到了main_main函数, 打开后看了眼汇编发现头疼, 果断F5: __int64 __fastcall main_main(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6) { /* 一大堆变量声明,节省篇幅就不看了 */ /* 对解题没什么用的函数 */ fmt_Fscanln(a1, a2, (__int64)\u0026v23, (__int64)\u0026unk_4AAF60, v7, v8, (__int64)\u0026go_itab__os_File_io_Reader, os_Stdin); if ( *v19 == 1107LL ) { runtime_convTstring(a1, a2, v9); *(_QWORD *)\u0026v22 = \u0026unk_4B0720; *((_QWORD *)\u0026v22 + 1) = \u0026v23; fmt_Fprintln( a1, a2, v12, (__int64)\u0026go_itab__os_File_io_Writer, v13, v14, (__int64)\u0026go_itab__os_File_io_Writer, os_Stdout); } /* 后面一个else一个return,都不是重点 */ } 一不小心看到了代码里有一个Fscanln, 想着这肯定是读取输入, 得了, 分析一下, 不用再找flag了, 然后发现if语句里比较了v19和1107LL, 果断打开题目给的exe, 然后输入1107, 成功拿到flag! flag: moectf{G0_1Anguage_1s_1nT3r3st1ng} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:6","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Java RE 给大佬递咖啡~ 诶,劳资咖啡咧, 好像丢了… 这道题, 用JD-GUI反编译了一下, 得到了一份狠长的代码: package qqq; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JTextField; public class Box implements ActionListener { /* 一堆变量声明 */ public static boolean CHECK(int input) { if (input \u003e 10000000 \u0026\u0026 input \u003c 99999999) { int v7 = 1; int v8 = 10000000; int v3 = 1; if (Math.abs(input / 1000 % 100 - 80) == 3 \u0026\u0026 input % 1000 % 927 == 0) { int v5 = 0; while (v5 \u003c 4) { if (input / v7 % 10 != input / v8 % 10) { v3 = 0; break; } v7 *= 10; v8 /= 10; v5++; } if (v3 != 1) { return false; } if (v3 == 1) { return true; } } } return false; } public Box() { /* UI设置, 对题目没什么用, 为省篇幅不列出了 */ } public static void main(String[] args) { } public void actionPerformed(ActionEvent e) { /* 一些废话, 一堆if, 省篇幅就不粘贴进来了 */ if (e.getSource() == this.bt) { if (CHECK(Integer.parseInt(this.a))) { this.tx.setText(\"moectf{\" + (char) (Integer.parseInt(this.a) / 1000000) + (char) (Integer.parseInt(this.a) / 10000 % 100) + (char) (Integer.parseInt(this.a) / 100 % 100) + \"_he}\"); } else { this.tx.setText(\"clear and try again!\"); } } /* 和解题无关的处理 */ } } 我把源代码精简了一下, 以便看得更清楚点. 既然是一个GUI程序, 开始运行当然不能找main了.. 注意到题里有个actionPerformed, 好, 就从这个函数开始吧.. 然后在最后面看见了CHECK, 再调转头去看CHECK, 发现是一个检测输入的函数. 根据if (input \u003e 10000000 \u0026\u0026 input \u003c 99999999)知道输入是一个八位数, 接着看if (Math.abs(input / 1000 % 100 - 80) == 3 \u0026\u0026 input % 1000 % 927 == 0)知道了中间两位是83或者77 ( 第一次做的时候没看见abs函数,浪费了n久最后发现差点气得摔键盘 ) 最后3位是927. while (v5 \u003c 4) { if (input / v7 % 10 != input / v8 % 10) { v3 = 0; break; } v7 *= 10; v8 /= 10; v5++; } 这个循环是用来判断回文数字的, 我们已经知道了八位数的后五位是77927, 对称过去就是72977927. 然后回到actionPerformed函数, 发现这么几句: if (CHECK(Integer.parseInt(this.a))) { this.tx.setText(\"moectf{\" + (char) (Integer.parseInt(this.a) / 1000000) + (char) (Integer.parseInt(this.a) / 10000 % 100) + (char) (Integer.parseInt(this.a) / 100 % 100) + \"_he}\"); } 这个提取出来了72977927的前六位72, 97, 79并用ASCII解码, 然后把字符串拼起来.. 出于懒, 写一小程序, 解之: ##include \u003ciostream\u003e using namespace std; int main() { char a = 72; char b = 97, c = 79; cout \u003c\u003c \"moectf{\" \u003c\u003c a \u003c\u003c b \u003c\u003c c \u003c\u003c \"_he}\" \u003c\u003c endl; return 0; } 咖啡真好喝~ ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:7","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Mine Sweep 这道题没什么好说的…我扫雷通关了…真逆向的话, 我还没有试过. ( 逃… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:8","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy RE 有了对上面的Easy的体验我丝毫不敢觉得这题狠easy…果不其然, 扔进IDA之后我一脸蒙圈, 这是个什么玩意儿啊… 不管了, 找到了main, 然后F5, 得到以下东东: __int64 __fastcall main(__int64 a1, char **a2, char **a3) { /* 变量声明 */ v11 = 0; sub_4011E0(a1, a2, a3); v10 = 1; v4 = 4194587627529708148LL; v5 = 653654411009211005LL; v6 = 4502494060534902393LL; v7 = 1048127506; v8 = 12340; v9 = 77; printf(\u0026byte_4040B0); sub_401270(\u0026v4); sub_4012A0(); return 0LL; } 啊嘞? 这画风怎么这么奇怪? 我看了眼题目描述, 得, AntiAntiDebug我一准儿是不会了, 那就解码吧… 顺着函数找了好久 signed __int64 __fastcall sub_401270(_BYTE *a1) { *a1 = 109; sub_401240(byte_404080); return 5LL; } int sub_4012A0() { return printf(\u0026byte_40409F); } 这是main里面提到的两个函数, 分别看了下, 一个指向byte_404080, 一个指向byte_40409F 本以为是那些常用的编码的decode, 结果发现根本没有这些字串…于是, 我想到了Moe RE… 先找到了byte_404080, 在长下面这样: .data:404080 byte_404080 db 74h, 22h, 28h, 2Eh, 39h, 2Bh, 36h, 3Ah, 7Dh, 3Ah, 12h\r.data:404080 ; DATA XREF: sub_401270+8↑o\r.data:404080 ; sub_401360+96↑r ...\r.data:404080 db 3Eh, 39h, 3Fh, 12h, 9, 79h, 2Eh, 7Dh, 29h, 7Eh, 12h\r.data:404080 db 7Ch, 3Eh, 12h, 28h, 79h, 3Eh, 34h, 30h, 4Dh 按照MoeRE的思想, 我想着找个数来挨个异或一下试试..然后写了个小程序: ##include \u003cstdio.h\u003e int main(void) { int v404080[] = { 0x74, 0x22, 0x28, 0x2E, 0x39, 0x2B, 0x36, 0x3A, 0x7D, 0x3A, 0x12, 0x3E, 0x39, 0x3F, 0x12, 0x09, 0x79, 0x2E, 0x7D, 0x29, 0x7E, 0x12, 0x7C, 0x3E, 0x12, 0x28, 0x79, 0x3E, 0x34, 0x30, 0x4D }; int key = 77; int i = 0; int b; do{ printf(\"%x\", v404080[i] ^ key); i++; b = (i \u003c 30); } while (b); return 0; } 第一次试的时候, key用的是 a1 的 109 , 然后发现不对…? 后来看了一眼main里面的v4~v9, 感觉太大的数怎么也不可能当key, 就拿77试了试… 然后运行了下flag就出来了…? ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:9","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Algorithm Task 这道题一看文件名叫hard就知道肯定不简单… 扔进IDA, 然后看到了一副宏伟壮观的程序跳转画面…… 果断找到main函数按F5, 然后看见了Decompiling窗口卡了半天, 最后出来了下面的代码: __int64 __fastcall main(__int64 a1, char **a2, char **a3) { /* 200多个变量声明 */ v186 = 0; v184 = 0; v187 = 0; v175 = 1093207085; /* 5个嵌套的 while(1) */ /* 一大堆不知所以的计算过程 */ /* 还有仨Wrong Flag的判定 */ if ( v175 == -866985480 ) { a2 = (char **)\"dcba3261b6ef0d77\"; v107 = strncmp(s1, \"dcba3261b6ef0d77\", 0x10uLL); v108 = 1750495256; // 找到第一个字符串, 盲猜是MD5加密 if ( v107 ) v108 = 402522278; v175 = v108; } // 一大堆else if,并不是很能看懂在干什么 else if ( v175 == 184885918 ) { puts(\"Please input the flag:\\n\"); // 然后看见了输入 a2 = (char **)\u0026s2; __isoc99_scanf(\"%42s\", \u0026s2); v188 = strncmp(\"moectf{\", \u0026s2, 7uLL) != 0;// 前缀不参与 /* 另一大堆不明所以的加密 */ else if ( v175 == 233838060 ) { a2 = (char **)sub_630390(\u0026v183, a2, a3); v189 = strcmp((const char *)(unsigned int)\"X1I0X0YxYWdfWTB1XzRyZV9TdHIwbmd9\", (const char *)a2) != 0; a3 = (char **)0xFFFFFFFFLL; /* 又是浩如烟海的看不懂的加密过程... */ } } } getchar(); return 0LL; } 在源代码中看见了dcba3261b6ef0d77和X1I0X0YxYWdfWTB1XzRyZV9TdHIwbmd9两串可疑的东东, 前面那串要么是MD5要么是SHA1, 后面那串肯定是Base系列的, 根据题目给的信息, 本题仅用了两种常见算法, 基本可以确定把俩解出来的字符串拼起来前面加上moectf{就OK了. 在网上找个工具成功解出flag: moectf{enj0y_R4_F1ag_Y0u_4re_Str0ng} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:10","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy C++ 由于得到了我大哥的帮助, 我算是成功的解出来了这道题.. 由于写WP的环境换到了Linux, 就简单的讲一下这道题的思路吧.. 这道题的flag: moectf{CPP_BaSE64_CaeS@r_1S_s0_eaaaasy} 做题思路: 经过我大哥Apache553的努力, 把IDA中所有的函数全部识别了出来, 这道题才得以破解. 用OllyDebug调试过程中找到字符串比较的函数的汇编代码然后跟进, 可以在堆栈中发现一串base64, 应该是对应的密文. 通过Apache553的工程文件大概得知这是使用移位的方式构建了一个新的table, 于是写脚本循环构建table, 最终将flag爆破了出来. ( 我挺想写详细过程的, 但是Windows找不到显卡了开不了机, 就只能先凑合了… ) ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:2:11","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Programming ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy PPC 读了下题目给的代码, 大概懂了意思之后, 写了一段小程序, 读取文件, 然后把数字提取出来: ##include \u003ciostream\u003e using namespace std; int main(){ freopen(\"flag.txt\", \"r\", stdin); char x; while(cin \u003e\u003e x) if(isdigit(x)) cout \u003c\u003c x; return 0; } 得到了这么一串数字: 109111101991161021231128911610448110957811184956511097994811010064125 然后工具人基因觉醒, 手动分类, 分成ASCII应该有的样子: 109 111 101 99 116 102 123 112 89 116 104 48 110 95 78 111 84 95 65 110 97 99 48 110 100 64 125 然后再写一个程序: ##include \u003ciostream\u003e using namespace std; int x; int main(){ while(cin \u003e\u003e x){ putchar(x); } } 就是无脑把x当成char来输出.. 把刚分好类的数字粘贴进去, 最后得到flag: moectf{pYth0n_NoT_Anac0nd@} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"w1nd牛逼！ 拿到这题, 面无表情的解压, 面无表情的用Visual Studio Code打开文件夹, 面无表情的点开在文件中搜索, 面无表情的输入w1ndNiuBi, 面无表情的打开全字匹配的开关, 面无表情的把总数扔进在线base64编码, 得到结果moectf{NjMyNA==}, 面无表情的提交… ( 好没意思的题 ( 溜了溜了 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"A Template Problem 这个题看着只有一百分我却写了好久好久… 仿佛又回到了以前写NOIP却怎么也写不出来只能百度求助而对着求助来的代码不知所措的年代😭 这题要用到KMP算法…什么是KMP算法咧? 就是一个快速的模式串匹配算法… 啥又是模式串匹配? 模式串匹配, 就是给定一个需要处理的字符串 ( 会超级超级长 ) 和一个需要在文本串中搜索的模式串 ( 理论上长度应该远远小于需要处理的字符串, 否则没法玩了… ) , 查询在该文本串中, 给出的模式串是否出现, 出现的次数, 出现的位置等等等问题. 为啥要叫KMP? 因为有三位伟大的科学家共同设计完成……分别是D.E.Knuth \u0026 J.H.Morris \u0026 V.R.Pratt 然而我并不需要知道他们都是谁谁谁…只需要知道这是个很流批的算法就好了.. 从洛谷学来的: 首先要理解，朴素的单模式串匹配大概就是枚举每一个文本串元素，然后从这一位开始不断向后比较，每次比较失败之后都要从头开始重新比对，大概期望时间复杂度在 θ(n+m) 左右，对于一般的弱数据还是阔以跑的了滴。但是其实是可以被卡成O(nm)的。emmmm并且还是比较容易卡的。 而 KMP的精髓在于，对于每次失配之后，我都不会从头重新开始枚举，而是根据我已经得知的数据，从某个特定的位置开始匹配；而对于模式串的每一位，都有唯一的“特定变化位置”，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间。 比如我们考虑一组样例： 模式串：abcab 文本串：abcacababcab 首先，前四位按位匹配成功，遇到第五位不同，而这时，我们选择将abcab向右移三位，或者可以直接理解为移动到模式串中与失配字符相同的那一位。可以简单地理解为，我们将两个已经遍历过的模式串字符重合，导致我们可以不用一位一位地移动，而是根据相同的字符来实现快速移动。 模式串： abcab 文本串：abcacababcab 但有时不光只会有单个字符重复： 模式串：abcabc 文本串：abcabdababcabc 当我们发现在第六位失配时，我们可以将模式串的第一二位移动到第四五位，因为它们相同 . 模式串： abcabc 文本串：abcabdababcabc 那么现在已经很明了了， KMP 的重头戏就在于用失配数组来确定当某一位失配时，我们可以将前一位跳跃到之前匹配过的某一位。而此处有几个先决条件需要理解： 1、我们的失配数组应当建立在模式串意义下，而不是文本串意义下。因为显然模式串要更加灵活，在失配后换位时，更灵活简便地处理。 2、如何确定位置呢？ 首先我们要明白，基于先决条件11而言，我们在预处理时应当考虑当模式串的第 i位失配时，应当跳转到哪里.因为在文本串中，之前匹配过的所有字符已经没有用了——都是匹配完成或者已经失配的，所以我们的 kmp 数组（即是用于确定失配后变化位置的数组，下同）应当记录的是： 在模式串 str1 中，对于每一位 str1[i],它的 kmp 数组应当是记录一个位置 j, j ≤ i 并且满足 str1[i]=str1[j] 并且在 j != 1 时理应满足 str1[1] 至 str1[j - 1] 分别与 str[i - j + 1] ~str1[i - 1] 按位相等 上述即为移位法则 3、从前缀后缀来解释 KMP : 首先解释前后缀(因为太简单就不解释了 )： 给定串：ABCABA 前缀：A,AB,ABC,ABCA,ABCAB,ABCABA 后缀：A,BA,ABA,CABA,BCABA,ABCABA 其实刚才的移位法则就是对于模式串的每个前缀而言，用 kmp 数组记录到它为止的模式串前缀的真前缀和真后缀最大相同的位置（注意，这个地方没有写错，是真的有嵌套）。然而这个地方我们要考虑“模式串前缀的前缀和后缀最大相同的位置”原因在于，我们需要用到 kmp数组换位时，当且仅当未完全匹配。所以我们的操作只是针对模式串的前缀−−毕竟是失配函数，失配之后只有可能是某个部分前缀需要“快速移动”。所以这就可以解释 KMP中前后缀应用的一个特点： KMP中前后缀不包括模式串本身,即只考虑真前缀和真后缀,因为模式串本身需要整体考虑，当且仅当匹配完整个串之后；而匹配完整个串不就完成匹配了吗… 这个我觉得很详细了…那怎么根据KMP算法写代码呢..? ( 我觉得编程题的WP最难写, 还要写TreeDistance… ) 先把代码贴出来: ##include \u003cstdio.h\u003e ##include \u003cstring.h\u003e char S[1000000]=\"\",T[1000000]=\"\"; int next[100000]; void Next(char*T,int *next){ memset(next,0,strlen(T)); // 初始化动态数组,将其长度设置为0 int size = strlen(T); // 把next数组的长度扩展到和T的长度一致 int j = -1; next[0] = -1; for (int i = 1; i \u003c strlen(T); i++) { while (j \u003e -1 \u0026\u0026 T[j + 1] != T[i]) j = next[j]; if (T[j + 1] == T[i]) j++; next[i] = j; } } int KMP(char * S,char * T,int i){ int cnt = 0; // count的缩写 Next(T, next); int j = -1; int slen = strlen(S); int tlen = strlen(T); for (int i = 0; i \u003c slen; ++i) { while (j \u003e -1 \u0026\u0026 T[j + 1] != S[i]) j = next[j]; if (T[j + 1] == S[i]) ++j; if (j == tlen - 1) { printf(\"%d \",i - tlen + 2); ++cnt; j = next[j]; } } } int main() { scanf(\"%s\",S); scanf(\"%s\",T); KMP(S,T,1); //printf(\"%d \",i); //system(\"pause\"); return 0; } woc… 我不想写了… 代码原理已经放出来了,, 接下来的看代码吧… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:3","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Perfect Repeater 如果我能做出来我再写… 我还做不出来 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:4","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Frank NB! 我写这道题的时候… 差点就当了工具人… 不过还好有工具…. Frank NB! Visual Studio Code NB! 下载完题目给的压缩包, 然后解压, 然后进入文件夹, 然后右键在 V S Code 中打开, 然后点击左侧的放大镜, 然后输入 ^[a-zA-Z][0-9]{3,5}[~!@#$%^\u0026*()_+][A-Za-z]{0,8}$, 然后回车搜索… WD**D咋不对啊..?! 噢噢还得排除一下FrankNB?的文件… 工具人基因觉醒! 手动删掉了所有FrankNB?之后, 终于获取了正确的数, 然后SHA256算一遍之后拿到flag… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:5","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Random Encode 这题读了读代码, 发现还真就是随机加密… from random import Random from base64 import * from flag import flag r = Random() EncoderSet = [a85encode,b16encode,b32encode,b64encode,b85encode] for i in range(r.randrange(30,35)): Encoder = r.choice(EncoderSet) flag = r.choice(EncoderSet)(str(EncoderSet.index(Encoder)).encode()) + \\ b'w1ndNB' + Encoder(flag) with open('secret.txt','wb') as out: out.write(flag) 发现脚本应该是把正确的flag随机选加密方式加密了30多层, 然后就产生了一个40多MB的大家伙… 我忽然产生了一个想法, 既然有随机加密算法选择的提示, 那我何不把每种算法的提示头都算出来, 然后每解密一次, 就读个头然后查表, 对应解密呢? 然后就有了一个小脚本: from random import Random from base64 import * r = Random() EncoderSet = [a85encode,b16encode,b32encode,b64encode,b85encode] for i in EncoderSet: print(r.choice(EncoderSet)(str(EncoderSet.index(i)).encode())) 然后运行这个脚本N次之后, 统计得出所有加密方式可能出现的文件头: a85 = [b'Fa', b'0E', b'MA==', b'30', b'GA======'] b16 = [b'F#', b'0`', b'MQ==', b'31', b'GE======'] b32 = [b'G5', b'1\u0026', b'Mg==', b'32', b'GI======'] b64 = [b'GX', b'1B', b'Mw==', b'33', b'GM======'] b85 = [b'Gy', b'1]', b'NA==', b'34', b'GQ======'] 然后写了个脚本: from base64 import * a85 = [b'Fa', b'0E', b'MA==', b'30', b'GA======'] b16 = [b'F#', b'0`', b'MQ==', b'31', b'GE======'] b32 = [b'G5', b'1\u0026', b'Mg==', b'32', b'GI======'] b64 = [b'GX', b'1B', b'Mw==', b'33', b'GM======'] b85 = [b'Gy', b'1]', b'NA==', b'34', b'GQ======'] EncoderSet = [a85decode, b16decode, b32decode, b64decode, b85decode] point = 0 while point != -1: f = open('.\\\\secret.txt', 'rb') s = f.read() point = -1 n = s.find(b'w1ndNB') print(s[0:n]) x = s[0:n] if s[0:n] in a85: point = 0 if s[0:n] in b16: point = 1 if s[0:n] in b32: point = 2 if s[0:n] in b64: point = 3 if s[0:n] in b85: point = 4 else: point = -1 print('ERROR OR SUCCESS!') exit() with open('secret.txt','w') as out: out.write(EncoderSet[point](s[n+6:]).decode()) 然后!!! 我就迷茫了… 无论如何都匹配不上.. 循环只执行一遍不做任何处理就会退出.. 于是… 怎么能放弃呢?! 我就改动了一下, 把循环去掉, 然后人眼识别, 手动修改解码方式和位置… 手撕了三十一层, 得到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:6","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Tree Distance 想让我写算法解释吗? 不可能的… 我还想多活几年… 我把代码放出来吧… 算法是倍增求LCA, 可以百度了解一下. ( 其实本题最开始是网络版的, 网络版数据简单得多并且没有时间限制, 可惜我不会网络编程, 于是就走上了OJ这条不归之路 T_T , 数据太坑人了 ) // 再过不了我就换地方重写QAQ ##include \u003ccstdio\u003e ##include \u003ccstring\u003e using namespace std; const int maxn = 5e5; const int maxm = 8e5; struct node { int to, next, w; } edges[maxm]; int head[maxn], cnt, dp[maxn][20], dep[maxn], dist[maxn]; void addedge(int u, int v, int w) { edges[cnt].to = v; edges[cnt + 1].to = u; edges[cnt].w = edges[cnt + 1].w = w; edges[cnt].next = head[u]; edges[cnt + 1].next = head[v]; head[u] = cnt++; head[v] = cnt++; } void dfs(int s, int x) { dep[s] = dep[x] + 1; dp[s][0] = x; int t; for (int i = 1; (1 \u003c\u003c i) \u003c= dep[s]; i++) dp[s][i] = dp[dp[s][i - 1]][i - 1]; for (int i = head[s]; i != -1; i = edges[i].next) { t = edges[i].to; if (t == x) continue; dist[t] = dist[s] + edges[i].w; dfs(t, s); } } int LCA(int u, int v) { if (dep[v] \u003e dep[u]) u ^= v ^= u ^= v; for (int i = 20; i \u003e= 0; i--) { if ((1 \u003c\u003c i) \u003c= (dep[u] - dep[v])) { u = dp[u][i]; } } if (u == v) return u; for (int i = 20; i \u003e= 0; i--) { if ((1 \u003c\u003c i) \u003c= dep[u] \u0026\u0026 (dp[u][i] != dp[v][i])) { u = dp[u][i]; v = dp[v][i]; } } return dp[u][0]; } int WDNMD(int u, int v) { int z = LCA(u, v); return dist[u] - 2 * dist[z] + dist[v]; } int main() { int n, m, u, v, w; scanf(\"%d%d\", \u0026n, \u0026m); cnt = 0; memset(head, -1, sizeof(head)); for (int i = 1; i \u003c n; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); addedge(u, v, w); // 强行无向... } dep[1] = 0; dp[1][0] = 1; dfs(1, 1); for (int i = 1; i \u003c= m; i++) { scanf(\"%d%d\", \u0026u, \u0026v); printf(\"%d\\n\", WDNMD(u, v)); } return 0; } ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:7","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"F1@g‘s diamond 代码一扔我就溜~ 算法是线段树, 区间维护. ##include\u003ccstdio\u003e ##include \u003ccstring\u003e ##include\u003ciostream\u003e using namespace std; typedef long long LL; const int INF = 1e9 + 7, MAXN = 5e5 + 10, MAXNODE = MAXN \u003c\u003c 2, MAXM = 1e5 + 10; int N, M; LL tmp[MAXN]; struct node { LL sum, maxl, maxr, maxv; node() { sum = maxl = maxr = maxv = 0; } } A[MAXNODE]; inline void push_up(int x) { A[x].sum = A[x \u003c\u003c 1].sum + A[x \u003c\u003c 1 | 1].sum; A[x].maxl = max(A[x \u003c\u003c 1].maxl, A[x \u003c\u003c 1].sum + A[x \u003c\u003c 1 | 1].maxl); A[x].maxv = max(A[x \u003c\u003c 1].maxr + A[x \u003c\u003c 1 | 1].maxl, max(A[x \u003c\u003c 1].maxv, A[x \u003c\u003c 1 | 1].maxv)); A[x].maxr = max(A[x \u003c\u003c 1 | 1].maxr, A[x \u003c\u003c 1].maxr + A[x \u003c\u003c 1 | 1].sum); } void init(int x, int l, int r) { if (l == r) { A[x].sum = A[x].maxl = A[x].maxr = A[x].maxv = tmp[l]; return; } int mid = (l + r) \u003e\u003e 1; init(x \u003c\u003c 1, l, mid); init(x \u003c\u003c 1 | 1, mid + 1, r); push_up(x); } void update(int x, int l, int r, int q, LL c) { if (l == r) { if (l == q) A[x].sum = A[x].maxl = A[x].maxr = A[x].maxv = c; return; } int mid = (l + r) \u003e\u003e 1; if (q \u003c= mid) update(x \u003c\u003c 1, l, mid, q, c); else update(x \u003c\u003c 1 | 1, mid + 1, r, q, c); push_up(x); } node query(int x, int l, int r, int ql, int qr) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { return A[x]; } int mid = (l + r) \u003e\u003e 1; if (qr \u003c= mid) return query(x \u003c\u003c 1, l, mid, ql, qr); if (ql \u003e mid) return query(x \u003c\u003c 1 | 1, mid + 1, r, ql, qr); node left = query(x \u003c\u003c 1, l, mid, ql, qr), right = query(x \u003c\u003c 1 | 1, mid + 1, r, ql, qr), ret; ret.maxv = max(left.maxr + right.maxl, max(left.maxv, right.maxv)); ret.maxl = max(left.maxl, left.sum + right.maxl); ret.maxr = max(right.maxr, left.maxr + right.sum); return ret; } int main() { scanf(\"%d%d\", \u0026N, \u0026M); for (int i = 1; i \u003c= N; i++) scanf(\"%lld\", tmp + i); init(1, 1, N); int ii, jj, kk; LL ll; for (int i = 1; i \u003c= M; i++) { ii = 1; if (ii == 1) { scanf(\"%d%d\", \u0026jj, \u0026kk); if (jj \u003e kk) swap(jj, kk); printf(\"%lld\\n\", query(1, 1, N, jj, kk).maxv); } else { scanf(\"%d%lld\", \u0026jj, \u0026ll); update(1, 1, N, jj, ll); } } return 0; } ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:3:8","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Crypto ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Pigpen Cipher 这个是猪圈密码, 从必应上可以搜到猪圈密码的密码表, 对着破解就可以了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Rail fence cipher mthAf2p_anf@ccta}ofEi3_hl_d_sar0pe{_Lncesk_cslyghctr_c12_i0li_pry 栅栏密码, 必应了解了一下, 发现分组, 然后就找了一下o, 通过o的判断发现分组的奥妙: mthAf2p_anf@ccta} ofEi3_hl_d_sar0p e{_Lncesk_cslygh ctr_c12_i0li_pry 然后竖着读就可以找到flag啦. flag: moectf{thE_rAiL_f3nc2_c1phe2_ls_a_kind_0f_cl@ssical_crypt0graphy} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Bacon’s Cipher AqCEclcIZQjbecyOhgXSwOdveKjpYyaeknUkyokazpyUnhFDSmvQEvCdmoFsfAvfyvTQFWkyBNIojUddNbtmT 这道题居然是以大小写来隐藏信息的!!! 然后就有了下面这个程序: ##include \u003ciostream\u003e ##include \u003ccctype\u003e using namespace std; int main () { char x; while(cin \u003e\u003e x) { if(isupper(x)) cout \u003c\u003c 0; else cout \u003c\u003c 1; } } 运行一下, 得到了一串二进制: 0100111000111110110010111011011111011111111011000110010111011011110000110001101101110 手动分割一下: 01001 11000 11111 01100 10111 01101 11110 11111 11101 10001 10010 11101 10111 10000 11000 11011 01110 发现解密的不对! 11111太夸张了…然后改一下代码, ##include \u003ciostream\u003e ##include \u003ccctype\u003e using namespace std; int main () { char x; while(cin \u003e\u003e x) { if(isupper(x)) cout \u003c\u003c 1; else cout \u003c\u003c 0; } } 再运行, 得到了另一串二进制 ( 其实就是上面的结果的按位非运算 ) 10110 00111 00000 10011 01000 10010 00001 00000 00010 01110 01101 00010 01000 01111 00111 00100 10001, 对着字母序号表解出flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:3","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Frequency analysis? 一看题目, 频率分析啊… 我不能当工具人! 于是写一程序: ##include \u003ciostream\u003e ##include \u003cmap\u003e ##include \u003calgorithm\u003e using namespace std; int main() { freopen(\".\\\\chars.txt\", \"r\", stdin); freopen(\".\\\\frequentre.txt\", \"w\", stdout); map\u003cchar, int\u003e sign; string input; string types; cin \u003e\u003e input; for(int i = 0; i \u003c input.length(); i++) { if (types.find(input[i])==string::npos) types += input[i]; sign[input[i]]++; } sort(types.begin(), types.end()); double total = input.length(); double frequent; for (int i = 0; i \u003c types.length(); i++) { frequent = double(sign[types[i]]) / total; cout \u003c\u003c types[i] \u003c\u003c \": \" \u003c\u003c frequent \u003c\u003c \"%\\n\"; } return 0; } 然后打开结果的文件, 再复制拖到Excel里面, 然后根据频率大小排序, 然后从上往下读就得到flag了… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:4","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"MD5 必应, 找一网站, 复制粘贴, 查询之, 得flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:5","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Columnar Transposition 维基百科对列移位密码的解释如下: ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:6","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Columnar transposition In a columnar transposition, the message is written out in rows of a fixed length, and then read out again column by column, and the columns are chosen in some scrambled order. Both the width of the rows and the permutation of the columns are usually defined by a keyword. For example, the keyword ZEBRAS is of length 6 (so the rows are of length 6), and the permutation is defined by the alphabetical order of the letters in the keyword. In this case, the order would be “6 3 2 4 1 5”. In a regular columnar transposition cipher, any spare spaces are filled with nulls; in an irregular columnar transposition cipher, the spaces are left blank. Finally, the message is read off in columns, in the order specified by the keyword. For example, suppose we use the keyword ZEBRAS and the message WE ARE DISCOVERED. FLEE AT ONCE. In a regular columnar transposition, we write this into the grid as follows: 6 3 2 4 1 5\rW E A R E D\rI S C O V E\rR E D F L E\rE A T O N C\rE Q K J E U providing five nulls (QKJEU), these letters can be randomly selected as they just fill out the incomplete columns and are not part of the message. The ciphertext is then read off as: EVLNE ACDTK ESEAQ ROFOJ DEECU WIREE In the irregular case, the columns are not completed by nulls: 6 3 2 4 1 5\rW E A R E D\rI S C O V E\rR E D F L E\rE A T O N C\rE This results in the following ciphertext: EVLNA CDTES EAROF ODEEC WIREE To decipher it, the recipient has to work out the column lengths by dividing the message length by the key length. Then he can write the message out in columns again, then re-order the columns by reforming the key word. In a variation, the message is blocked into segments that are the key length long and to each segment the same permutation (given by the key) is applied. This is equivalent to a columnar transposition where the read-out is by rows instead of columns. Columnar transposition continued to be used for serious purposes as a component of more complex ciphers at least into the 1950s. 不过这题有很大的坑… 就是解密顺序和加密是反着来的.. 我之前搞了好久都搞不出来… 按照Wiki分组重排, 成功拿到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:7","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy RSA 这道题我研究了好久… 最后在线分解大数找到p和q, 然后bing搜来的脚本修改一下跑一遍就过了… ##coding=utf-8 import math import sys from Crypto.PublicKey import RSA arsa=RSA.generate(1024) arsa.p=296173636181072725338746212384476813557 arsa.q=336771668019607304680919844592337860739 arsa.e=65537 arsa.n=arsa.p*arsa.q Fn=long((arsa.p-1)*(arsa.q-1)) i=1 while(True): x=(Fn*i)+1 if(x%arsa.e==0): arsa.d=x/arsa.e break i=i+1 private=open('private.pem','w') private.write(arsa.exportKey()) private.close() 拿到私钥之后, 随便用个什么方法, openssl也好, 在线解密也好, 反正就出来了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:8","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Hill Cipher 这题我真的是写到地老天荒… 拿到题之后先找了无数个网站发现解不了, 就自己研究了一下, 发现矩阵求逆然后和密文求点积, 于是我就打开微软的Mathematics算了一年得到了输出, 然后写一程序手动输入弄出flag… 具体情况呢, 就是题目给了个矩阵密钥, 先求逆, 然后存下来和分好组的密文挨个求点积, 最后输出结果时, 把小数部分直接舍掉就行了, 然后输入下面的程序里开始查表. ##include \u003ciostream\u003e using namespace std; int main(){ string table = \"abijklQRSTUVWXmnop@#$%wxyzABCDcdefghEFGHI\u0026*()_+JKLMNOPYZ01234qrstuv56789!^-=\"; while(true){ double y; cin \u003e\u003e y; int x = int(y); x %= table.length(); if(x \u003c= 0) x += table.length(); cout \u003c\u003c table[x]; } } // 算出来的明文长这样, 注意要竖着输进去 // 49 0 5 7 8 56 57 28 // 57 62 34 0 45 52 33 65 // 15 45 58 45 63 45 33 49 // 58 26 1 57 16 29 2 64 flag: moectf{L1n2ar_Alg2bRa_1S_so0O_D1ffiCuLt} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:4:9","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Web ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"GET 浏览器打开http://39.108.11.206:10002/?a拿到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"POST 去网上找了个叫HackBar的东西, 然后就post了… 不过后来用脚本的办法, 拓展性高一点: import requests datas = {'a'} r = requests.post(\"http://39.108.11.206:10001/\", data=datas) print(r.text) print(r.status_code) ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Introducing Web 打开网页, 然后按F12, 然后..就没有然后了.. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:3","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy Limitation 打开网页, 保存到本地, 打开HTML, 把下面这句: \u003cinput class=\"form-control\" type=\"text\" name=\"key\" maxlength=\"14\" placeholder=\"只需要输入msc_1s_Gre@t即可获取flag\"\u003e 里的maxlength改成15或者更大的数, 然后本地浏览器打开改好的html, 输入, 提交, 拿到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:4","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Procotol 从php的官方文档里读了好久…然后拼出来这么一句: http://39.108.11.206:10003/?file=php://filter/read=convert.base64-encode/resource=./index.php 浏览器打开后能看到一串base64串, 复制下来解码: \u003c?php error_reporting(0); echo '\u003cp\u003ethe flag was put in the index.php, can you get it?\u003c/p\u003e'; $file=$_GET['file']; include($file); //moectf{YoU_g0t_f1@g} ?\u003e 然后就拿到flag了… 说来这种把源码换成base64再输出防止被执行的方法真骚啊.. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:5","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Restrictions 搜索引擎会读取站点下的robots.txt来判断爬取哪些页面. 然后我们打开https://moectf.cn/robots.txt, 发现提示有什么脚本被执行了删掉了flag… 打开设置禁用JS脚本, 刷新网页, F12, 在源代码里看见flag… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:6","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"是时候展示十八年单身的手速了 这道题要用到WireShark…然后点开WireShark, 打开端口然后刷新页面, 然后在捕获的列表里面找一个HTTP 302, 然后双击查看详细信息, 就能找到flag了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:7","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"英国人 这道题很秀…. 用nslookuptool的在线查询网站可以查到region.challenge.moectf.cn的全球dns信息, 然后找到了域名在英国被解析的地址, 然后修改一下hosts, 唱跳rap篮球+F5, 就拿到flag了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:8","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Amazing_Eval 了解了一下eval()函数.. 然后打开http://39.108.11.206:10006/?cmd=‘echo “$flag”’就好了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:9","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"今天你备份了嘛 这道题上网必应了一下, 然后打开http://39.108.11.206:10011/index.php.swp, 就拿到flag了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:10","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"PHP 弱类型 我真的想吐槽PHP不愧是被骂成全世界最懒烂的语言… http://39.108.11.206:10005/?a=\"0” php判断相等时, 字符串会被解释成0. 打开上面网址拿到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:11","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"PHP_md5() 哇塞php是真的不安全…必应了一下php的MD5漏洞, 然后打开http://39.108.11.206:10007/?username=240610708\u0026passwd=QNKCDZO, 就拿到了flag: moectf{You_UnderStAnd_mD5_betTer!} 这是因为240610708和QNKCDZO的MD5()计算结果竟然是一样的! ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:12","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"神奇的正则表达式 小小学了下正则表达式, 然后改了一下之前post用的脚本: import requests datas = {'key':\"aflagdddd/6/:skey\"} r = requests.post(\"http://39.108.11.206:10009/\", data=datas) print(r.text) print(r.status_code) 成功通过. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:13","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"头 这题真的狠…算了要文明… 用curl连试了好几次终于过了: $ curl --header \"Cookie: login=true\" --header \"User-Agent: PowerPC\" --header \"Accept: application/flag\" -v -i http://47.101.32.101:10010/ 就是按照网页的提示改HTTP请求头就好了. flag: moectf{M0m_I_c4n_m0dify_HTTP_H3aders!} 这个flag写的也让人很想吐槽…. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:14","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"stronger_php 这个竟然判断md5==sha1……. 用数组绕过, 浏览器打开http://39.108.11.206:10008/?a[]\u0026b[]=123123 得到flag: moectf{Y0u_can_st1ll_defeat_m3} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:15","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"终极HTTP请求头 我!!!!! 想杀人… 先挂出来我的狗血历程🙃: ## 上面省略2232行尝试的代码 rever@DS-10001-RX MINGW64 ~ $ curl --header \"Referer: www.xidian.edu.cn\" --header \"User-Agent: moectf_browser\" --header \"X-Forwarded-For: 127.0.0.1\" --header \"Cookie: xduer\" --header \"Accept: PHP\" --header \"Accept-Encoding: UTF-8\" --header \"Accept-Language: zh-CN\" -v -i http://39.108.11.206:10012/ * Trying 39.108.11.206... * TCP_NODELAY set % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0* Connected to 39.108.11.206 (39.108.11.206) port 10012 (#0) \u003e GET / HTTP/1.1 \u003e Host: 39.108.11.206:10012 \u003e Referer: www.xidian.edu.cn \u003e User-Agent: moectf_browser \u003e X-Forwarded-For: 127.0.0.1 \u003e Cookie: xduer \u003e Accept: PHP \u003e Accept-Encoding: UTF-8 \u003e Accept-Language: zh-CN \u003e \u003c HTTP/1.1 200 OK \u003c Date: Fri, 06 Sep 2019 14:41:00 GMT \u003c Server: Apache/2.4.7 (Ubuntu) \u003c X-Powered-By: PHP/5.5.9-1ubuntu4.14 \u003c Vary: Accept-Encoding \u003c Content-Length: 443 \u003c Content-Type: text/html \u003c { [443 bytes data] 100 443 100 443 0 0 3141 0 --:--:-- --:--:-- --:--:-- 3141HTTP/1.1 200 OK Date: Fri, 06 Sep 2019 14:41:00 GMT Server: Apache/2.4.7 (Ubuntu) X-Powered-By: PHP/5.5.9-1ubuntu4.14 Vary: Accept-Encoding Content-Length: 443 Content-Type: text/html First of all, you must come from XiDian University\u003cbr\u003eSecond, you have to use moectf_browser\u003cbr\u003eThird, you have to visit from the localhost\u003cbr\u003eFourth, your identity must be xduer\u003cbr\u003eFifth, client can only accept PHP documents\u003cbr\u003eSixth, we only allow UTF-8 encoding\u003cbr\u003eFinally, we are only allowed to use Chinese.\u003cbr\u003eCongratulations on having a good understanding of HTTP HEADERS and finally getting flag:\u003cbr\u003emoectf{Reward_y0u_For_per3everAnce} * Connection #0 to host 39.108.11.206 left intact 试到最后一步看见flag里的那个perseverance我当时就想从四楼跳下去… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:16","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"朝鲜人 朝鲜人! wd**d, 我去哪儿找朝鲜dns啊QAQ 必应了好久找到一个阿里云的EDNS-CLIENT-SUBNET的使用介绍, 在我的Open SUSE Tumbleweed中运行如下: $ wget ftp://ftp.isc.org/isc/bind9/9.9.3/bind-9.9.3.tar.gz $ tar xf bind-9.9.3.tar.gz $ cd bind-9.9.3 $ wget http://wilmer.gaa.st/edns-client-subnet/bind-9.9.3-dig-edns-client-subnet-iana.diff $ yum -y install patch $ patch -p0 \u003c bind-9.9.3-dig-edns-client-subnet-iana.diff $ ./configure --without-openssl $ make 然后终端执行: $ /bin/dig/dig @8.8.8.8 region.challenge.moectf.cn +client=175.45.176.68 edns其实就是查询dns服务器的时候手动告知dns你是哪里的人, 然后dns就会返回一个你该访问的地址. 得到朝鲜解析的IP之后, 老方法修改hosts, 就得到了朝鲜人的flag. 从企鹅大佬的博客上找到了关于edns的详细解释, 现在很不要脸的引用过来: ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:17","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"1、什么是EDNS？ ​ EDNS就是在遵循已有的DNS消息格式的基础上增加一些字段，来支持更多的DNS请求业务。 需要注意的是，像DNS服务器这样一个大型且广泛应用的系统软件，新增加扩展协议的时候一定要考虑到向后兼容性(backward compatibility)，即你增加了你这个特性的消息传输给未支持该特性的服务器时，后者依然能正确处理。 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:18","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"2、为什么要有 EDNS？ ​ RFC2671中指出EDNS被提出来的几个理由： ​ 1）DNS协议头部的第二个16字节中都已经被用的差不多了，需要添加新的返回类型(RCODE)和标记(FLAGS)来支持其他需求； ​ 2）只为标示domain类型的标签分配了两位，现在已经用掉了两位（00标示字符串类型，11表示压缩类型），后面如果有更多的标签类型则无法支持； ​ 3）当初DNS协议中设计的用UDP包传输时包大小限制为512字节，现在很多主机已经具备重组大数据包的能力，所以要有一种机制来允许DNS请求方通知DNS服务器让其返回大包； ​ 以后我们会看到，DNSSEC机制和edns-client-subnet机制等都需要有EDNS的支持。 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:19","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"3、EDNS 的内容是什么？ ​ 怎样在DNS消息协议的基础上再增加一些字段呢？为了保持向后兼容性，更改已有的DNS协议格式是不可能的，所以只能在DNS协议的数据部分中做文章。 ​ 所以，EDNS中引入了一种新的伪资源记录OPT（Resource Record），之所以叫做伪资源记录是因为它不包含任何DNS数据，OPT RR不能被cache、不能被转发、不能被存储在zone文件中。OPT被放在DNS通信双方（requestor和responsor）DNS消息的Additional data区域中。 转自 赤道企鹅™的博客 ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:20","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Dynamic 这道题是考思维定势的… \u003c?php highlight_file(__FILE__); error_reporting(0); $blacklist = [\"system\", \"ini_set\", \"exec\", \"scandir\", \"shell_exec\", \"proc_open\", \"error_log\", \"ini_alter\", \"ini_set\", \"pfsockopen\", \"readfile\", \"echo\", \"file_get_contents\", \"readlink\", \"symlink\", \"popen\", \"fopen\", \"file\", \"fpassthru\"]; $blacklist = array_merge($blacklist, get_defined_functions()['internal']); foreach($blacklist as $i){ if(stristr($_GET[cmd], $i)!==false){ die('hack'); } } eval($_GET[cmd]); 打开题目的代码长这样, 能看到blacklist里面禁用了好多用来输出和操作文件的函数… 怎么办? 于是我研究了好久PHP的漏洞, 包括stristr()的漏洞, 最后除了发现print()函数还能用之外什么都做不了… 但是咧, 经过大哥的点拨, 我明白了, PHP的函数不能用, 但是我们可以用Linux的指令呀!!! 于是我们分析代码, 发现首先是没有除了cmd之外的变量供我们使用的, 所以我们需要构建一个新的变量. 这新的变量的名字我们暂且叫str好了, 反正也没有什么关系.. ( 因为我大哥这么取的名字 ) 接下来我们要读取这个str里的东西, 然后print出来. 最后跟上id的内容.. 但是怎么调用Linux的函数呢.? 这要提到PHP里面又一个神奇的东西: 反引号: ‘`’. PHP会把包含在反引号里面的东西当成Shell指令执行. 所以, 我们就可以快乐的构建一句话木马啦! Like this: ?cmd=$str=$_GET[id];print%20`$str`;\u0026id=ls 这样我们就可以调用ls指令来查看服务器当前文件夹里都有些什么东东.. 然后我们看见了两个文件, 一个是4f5f6c3be6ab7cc59dabf9ff7f2b248a\r另一个是index.php.. flag自然不可能存在index.php里啦, 我们用Linux里的cat指令来查看那个乱码文件里是些什么东西: ?cmd=$str=$_GET[id];print%20`$str`;\u0026id=cat+4f5f6c3be6ab7cc59dabf9ff7f2b248a 然后就拿到flag啦… flag: moectf{PLEASE_USE_disable_function!!!!!!} ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:5:21","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Android ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:6:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Android_Signin 手机下载, 打开, 拿flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:6:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"ClickIt 我教你们物理做法! 首先准备一个2.8V电动机, 然后找到一根棉签, 可以通过导线或者锡箔的方法让其可以被手机电容屏识别, 然后放在一个支架上. 电动机接好电源后, 在一段放置一个拨片,让其每转一圈拨片都会拨一下棉签, 最后把手机放在棉签头下面, 打开开关, 睡觉. 第二天早上起来就可以交flag了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:6:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"DevOps ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:7:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"SNI 这道题拿火狐打开可以发现证书只适用于*.sspirits.top, 于是修改hosts文件再修改HTTP请求头的Host, 然后就拿到了flag ( 但是我重新做的时候发现不对了… 我也很疑惑 ) ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:7:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"SNI++ 这道题好像很好做..题目的地址: 176.9.166.200 我使用了nslookup, 然后反查到了域名: 200.166.9.176.in-addr.arpa name = vps.stockservers.com. 然后修改hosts文件, 176.9.166.200 vps.stockservers.com 然后刷新网络再用火狐打开, 看到证书不匹配的安全警告点击跳过, 然后就拿到了flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:7:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"MISC ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"世界辣么大 就把程序拉开就行了, 程序窗口大小可变. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Easy base64 扔进在线解密网站里. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"网线大鲨鱼 拿WireShark打开, 然后导出数据, 在文件名那里就可以看见flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:3","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"你的脑洞够大吗 这道题!!! 先下载程序, 打开后去哪里找key, 然后给了一串数字, 说网络情缘一线牵. 网络情缘一线牵想到了QQ号, 然后打开QQ添加好友, 然后在主页照片墙看见另一个大佬的QQ号, 开了一堆会员.. 把QQ复制下来粘贴进key里面, 发现不对. 搜索这个人的QQ, 发现没有什么信息, 只有个人说明上有俩网址, 是吃鸡透视外挂的网址. 于是回到最开始的QQ账号, 点击添加好友, 在验证问题上看到了XDSEC的大佬ID, 明白这肯定是Key, 复制下来放进Key, 点了一下提示百朵云中定有不一样的颜色, 于是打开百度云, 把输入框里产生的那串乱码粘贴到百度网盘分享地址里, 然后打开发现需要提取码. 想起来题目上给的提取码 2m54 , 输进去, 果然是对的. 下载得到一个压缩包.解压后发现一个脚本和一个txt, 提示说多一个1也算失误. 然后打开脚本字串去掉开头的1, 剩下扔进base64, 解出得到flag. ( 这是我做过最像黑客的一道题, 确实很考脑洞但是很好玩, 富有挑战性. ) ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:4","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"被伪加密的文档 说来巧, 前几天下载注册机, 然后一不小心给电脑上装了360全家桶, 然后删软件时没删完, 不小心留了个360压缩… 然后做这题的时候压缩包就直接正常解压了! 然后就拿到flag了… 从那以后我觉得360压缩就留在电脑里吧… 正常做法是修改zip文件的hex码, 然后把标识是否加密的那个位给改过来. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:5","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"修复\u0026分离 用PS打开图片发现前半个flag, 然后拖进Linux用binwalk跑了一下发现有压缩包后缀, 就强行改成zip打开, 里面有一txt, 解压得到后半个flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:6","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Keyboard 这道题不用题解了吧… 就跟着文件里的按键顺序按一遍就好了…. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:7","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"恼人的Aliga 爱酱是真的漂亮! 好吧这不是重点… 重点就是… 你选中图片最下面没有aliga部分, 然后拉伸变形可以得到一个条形码..但是咧, 条形码扫不出来… 后来分析一下发现边界是白条, 这显然不是条形码应该有的样子, 就处理成反相然后拿微信扫一扫获取flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:8","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Secret Code 这个题嘛..也是社工, 我还买了hint… 把代码base64解密得到一串乱码, 加上从囧姐姐的主页看见的酷似提取码的东西, 于是再度打开百度云… 然后看见了帅气的PWN爷s@d. 拖进WinHex, 搜索moectf找到flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:9","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Base64? 哇塞这道题是真的做了很久很久… 其实是考的是Base64的原理, 上网bing了一下, 大致就是把字符变成二进制串然后重新分组重新断句, 就很神奇… 先给table编号, 00000000 x 00000001 y 00000010 U 00000011 V 00000100 z 00000101 A 00000110 B 00000111 C 00001000 D 00001001 E 00001010 F 00001011 G 00001100 H 00001101 I 00001110 J 00001111 K 00010000 L 00010001 M 00010010 N 00010011 O 00010100 a 00010101 b 00010110 c 00010111 d 00011000 e 00011001 f 00011010 g 00011011 h 00011100 i 00011101 j 00011110 k 00011111 l 00100000 m 00100001 W 00100010 X 00100011 Y 00100100 Z 00100101 0 00100110 1 00100111 2 00101000 3 00101001 4 00101010 5 00101011 6 00101100 7 00101101 8 00101110 9 00101111 P 00110000 Q 00110001 R 00110010 S 00110011 T 00110100 n 00110101 o 00110110 p 00110111 q 00111000 r 00111001 s 00111010 t 00111011 u 00111100 v 00111101 w 编好之后, 就可以通过查表的方式把密文翻译成二进制形式, 然后把每一段二进制的前两位0给去掉, 重新按照八位分组, 对照ASCII表就可以翻译出来. 这道题是在火车上写的, 就纯手撕了… 没有代码.. 不过查表和重新拼接的代码实现应该不怎么难… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:10","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"AiAiAi 作为第一个做出来这道题的人! 我要好好骄傲一会儿! 这道题其实就是音频隐写. 从Ardour的频谱上可以很清楚的看见尾部有东西.. 于是放大了看, 发现一些酷似莫尔斯电码的东西, 解码提交. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:11","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Osu Master 就把这题玩过去就行了.. 画的轨迹就是flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:12","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"s@d的嘲讽表情 这道题.. 反正我PWN爷最帅呗… 下载了图片拿stegsolve打开, 提取数据选择RGB的最低位, LSB First, 然后方式选择BGR, 点击Preview, 就可以看见flag了… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:13","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Kokoro 这题需要一个男朋友 ( BF )🙃 BF就是BrainFuck啦….想什么呢 打开文件之后手动展开, 如果是 20. ,展开之后就是20个 . ,以此类推, 全部展开了扔进Ook! 编码解码器里解出来flag. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:14","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"Show Off 最后一题了QAQ 写完睡觉! 这道题我擦二维码擦了一下午才擦干净… 然后就想方设法地实现这个函数了… 最后借鉴了大佬的作品, 才勉强把这题弄出来.. 用stegsolve打开二维码进行频率分析可以得到代码里的dic, 然后 def read(self, bit): # implement this # 请实现这一函数 index = 0 data = '' dic = [0x00, 0xff, 0x3f, 0xbf, 0xfe, 0x01, 0x40, 0xc0, 0xcf, 0xbe, 0x2f, 0x3e, 0x0f, 0x6f, 0xef, 0x9f, 0x5f, 0x8f, 0xee, 0x30, 0x2e, 0x90, 0x70, 0x60, 0x8e, 0xd0, 0x9e, 0xce] for i in range(self.width): print(i) for j in range(self.height): p = list(self.im.getpixel((i, j))) ifx = info.get(i*10000+j) if ifx != None: for k in range(3): if ifx | (1 \u003c\u003c bit) == p[k]: data += '1' elif ifx \u0026 ~(1 \u003c\u003c bit) == p[k]: data += '0' else: print(\"ERROR!\", i, j, k, ifx, p, bit) px = 0 for color in dic: if color | (1 \u003c\u003c bit) == p[k]: data += '1' px = 1 break if color \u0026 ~(1 \u003c\u003c bit) == p[k]: data += '0' px = 1 break if px == 0: print(\"not sel\") exit() bit = (bit+1) % 8 else: for k in range(3): px = 0 for color in dic: if color | (1 \u003c\u003c bit) == p[k]: data += '1' bit = (bit+1) % 8 px = 1 break if color \u0026 ~(1 \u003c\u003c bit) == p[k]: data += '0' bit = (bit+1) % 8 px = 1 break if px == 0: print(\"not sel\") exit() dat = bytearray() for i in range(int((len(data)-len(data) % 8)/8)): inx = int(data[i*8:i*8+8], 2) dat.append(inx) with open('flag1.jpg', 'wb') as f: f.write(dat) 然后把生成的图片拖进WinHex里, 就能看见flag了. ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:8:15","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"PWN ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:9:0","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"欢迎来到pwn的世界 这道题要用nc, 我就复制粘贴进了终端, 然后回车, 提示不要输入太多字母, 然后我百度了好久也没弄懂PWN为何物,于是.. 在某个月黑风高的夜晚我绝望的脸滚键盘, 滚了好多输入, 然后就看见flag蹦了出来… 后面还跟了一个栈溢出的提示… WD**D, pwn是这么玩的啊! ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:9:1","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"pwn1 这道题入门了分析起来就很简单, 把题目给的程序扔进IDA, 我们发现输入的漏洞在puts()函数, 如果输入过长它会覆盖后面的内容.. 经过查数, 当输入长度为120个A时会溢出到一个函数跳转的地方, 再看IDA, 我们用pwntools封装一下打印flag的函数地址0x00000000004006B6, 把封装好的数据包传给服务器, 完事! 说的不专业不准确就饶了我吧… 我想睡觉… 结束 wdnmd! 我终于写完了! 可以睡觉了… ","date":"2019-09-06","objectID":"/posts/moectf_2019_wp/:9:2","tags":["CTF"],"title":"MoeCTF 2019 题解","uri":"/posts/moectf_2019_wp/"},{"categories":["CTF"],"content":"前言 突然想到要写WP来着… 但是比赛还没结束, 现在放出来可能会被驱逐出赛emmmm 所以就先写着, 等到比赛完了一并放出. 不过这篇博文就不是什么WP啦, 就简单的说一下CTF的那些事儿. ( 很水的一篇博文 ) ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:1:0","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"CTF简介 因为军训原因, 这一篇博文拖了好久才决定在今晚更新了.. 否则到了明天又没时间了, 军训累人, 回来就想睡觉.. CTF的全称是 Capture The Flag 就是夺旗的意思.. 中文名字叫网络安全夺旗赛 , 看起来很高级的样子.. 在维基百科的解释如下: 好吧wikipedia并没有这个解释 在百度百科的解释如下: CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 。 CTF是种什么类型的比赛咧? 具体来说, 差不多就是几个大佬把一些flag四处隐藏, 然后参赛队伍通过各种方式去把flag找出来,差不多就这样了.. 根据寻找flag的难度来确定每一题的分数. ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:2:0","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"CTF题目类型 ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:0","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"Reverse 这差不多是我唯一做着不怎么难受的题了……只要肝的动, 就能做出来 ( 别提Easy C++了😭我知道我很菜 ) 逆向工程是什么咧? 就是传说中的Reverse! ( 废话 ) 好吧不废话了.. 逆向工程是: 一种技术过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理。 ——Wikipedia ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:1","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"Web 啥是Web? 互联网啊 ( 逃 Web指的是对网站的代码进行审计, 然后通过网站上存在的漏洞对进行破解从而获得自己想要的信息. ( 当然这是某升瞎说的定义,以这种严肃的方式写出来比较高大上 ( 溜了溜了 ) ) 了解到这儿, ( 反正某升到现在也弄不懂Web题应该怎么写 ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:2","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"Programming 这就是编程题了, 一般情况下主办方会有一个在线评测平台, 把写好的源代码提交上去AC就好啦! (说的容易 然后就能拿到flag……. ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:3","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"Crypto 密码题! 总而言之嘛,,, 密码题就是flag就摆在你眼前, 但你就是搞不开…….. 差不多就是这样 题目类型十分的广泛, 上到远古时期的移位密码, 下到目前最先进的国密算法都有涉及. 也是某升最头疼的题… 一个RSA算法弄到天昏地暗也不会… ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:4","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"Android 看题目也差不多了解了吧… 当然是和安卓有关的题🤪 题目一般是一个apk文件, 然后用各种各样的手段, 比如逆向工程, 或者手撕 ( 逃 ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:5","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"DevOps 这个分区至今没搞懂😁, 和SNI有关的题…? ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:6","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"PWN pwn! 你被PWN之王 s@d 使用 Pwntools 击倒了 ( 逃 别黑我………! ( 据说是和网络配合在一起的逆向题 ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:7","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["CTF"],"content":"MISC 杂项, 是CTF里面最好玩, 也是最考验脑洞的题…做不出来就真的做不出来了… 一般情况下, 是一些隐写题, 主办方会用各种手段把flag藏起来… ","date":"2019-08-21","objectID":"/posts/moectf_2019_inspirement/:3:8","tags":["CTF"],"title":"MoeCTF简记之初识CTF","uri":"/posts/moectf_2019_inspirement/"},{"categories":["Development"],"content":"回顾 上文我们已经搭建好一个基于 GitHub Pages 的播客啦, 但是 HEXO 自带的主题是真的丑…… 所以, 作为外观协会的成员(假的), 我觉得有必要美化一下我们的博客. 那怎么美化咧??? 会不会很麻烦? 你要是个死宅, 那还真挺麻烦的… ","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:1:0","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"开始吧 ","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:2:0","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"安装NexT主题 为了省事, 我们选择了美观而又方便的NexT主题. 安装这么做: $ git clone https://github.com/theme-next/hexo-theme-next themes/next 注意哦, 这一定是在你的博客目录下面执行的, 在别的文件夹下面是没有效果的哦! 然后你可以用编辑器打开站点配置文件_config.yml, 然后找到theme, 把landscape 改成 next就大功告成啦! 但是一定要注意哦, 对于yml文件, 每个属性名称冒号的后面一定是有一个空格的, 否则设置会出错哦! theme: next #注意 ‘:’ 后面是有空格的! ","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:2:1","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"初级配置 现在我们对NexT主题进行一个小小的配置. 打开博客文件夹下的themes → next → _config.yml文件, 对,也叫 _config.yml …… 不要晕了哦! NexT提供了四种主题风格，分别是Muse、Mist、Pisces、Gemini, 可以在刚打开的_config.yml里找到scheme这一项进行修改,然后 : $ hexo s 浏览器打开 本地博客 就能看见你的新主题啦! 想立刻部署到GitHub? 没问题呀, 但是我们先不急……在本地配置满意了在上传也不迟呀. ","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:2:2","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"自定义外观 笔者的站点配置文件 ( 可以先跳过 ) 我先在这里贴一下我的站点配置,可以先跳过哦: 主题配置文件: ## --------------------------------------------------------------- ## Theme Core Configuration Settings ## See: https://theme-next.org/docs/theme-settings/ ## --------------------------------------------------------------- ## If false, merge configs from `_data/next.yml` into default configuration (rewrite). ## If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings. ## And if true, all config from default NexT `_config.yml` must be copied into `next.yml`. Use if you know what you are doing. ## Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config. override: false ## Console reminder if new version released. reminder: false ## Allow to cache content generation. Introduced in NexT v6.0.0. cache: enable: true ## Remove unnecessary files after hexo generate. minify: false ## Define custom file paths. ## Create your custom files in site directory `source/_data` and uncomment needed files below. custom_file_path: #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/styles.styl ## --------------------------------------------------------------- ## Site Information Settings ## See: https://theme-next.org/docs/getting-started/ ## --------------------------------------------------------------- favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml ## hexo-generator-feed required for rss support. Leave rss as blank to use site's feed link. ## Set rss to false to disable feed link. Set rss to specific value if you have burned your feed already. rss: /atom.xml footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # Icon between year and copyright info. icon: # Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: \"#808080\" # If not defined, `author` from Hexo `_config.yml` will be used. copyright: Reverier powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: false theme: # Theme \u0026 scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # Beian ICP information for Chinese users. See: http://www.beian.miit.gov.cn beian: enable: false icp: baidushare: type: button baidushare: true jiathis: true ## Creative Commons 4.0 International License. ## See: https://creativecommons.org/share-your-work/licensing-types-examples ## Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero ## You can set a language value if you prefer a translated version of CC license, e.g. deed.zh ## CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org creative_commons: license: zero sidebar: false post: false language: ## --------------------------------------------------------------- ## SEO Settings ## --------------------------------------------------------------- ## Disable Baidu transformation on mobile devices. disable_baidu_transformation: false ## Set a canonical link tag in your hexo, you could use it for your SEO of blog. ## See: https://support.google.com/webmasters/answer/139066 ## Remember to set up your URL in Hex","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:2:3","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"结束 这么一来我们的博客初始化就结束啦! 后续有问题请留言评论或者在页面上的聊天窗口中直接联系我哦! ","date":"2019-08-19","objectID":"/posts/beautify_your_blog/:3:0","tags":["Web","Development"],"title":"用Next美化 HEXO \u0026 GitHub 博客","uri":"/posts/beautify_your_blog/"},{"categories":["Development"],"content":"废话 作为一个小白,在WEB方面的小白,搭建一个简单的静态博客确实费了许多精力.其中参考了无数资料,有官方的,非官方的…反正搭建不易,现在就详述一下,博客是怎么搭建起来的. 没错,看到这个一级标题了吧,这篇文章里面不是一个水到渠成的方法,我会把我所踩过的坑以及踩坑用的方法写进来,所以…😜 噢,笔者很穷,用不起Mac,所以就不会Mac的做法咯~ 原创,转载请注明来源 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:1:0","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"准备工作 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:2:0","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"Git 准备什么咧?因为我们的博客是建在GitHub上啦,所以你需要一个Git. Git 下载地址 按照Windows下面装软件的惯例,就 下一步 下一步 下一步 我同意 下一步 下一步 安装 完成 就装好啦~ 如果是Linux, Git 应该已经集成到大部分的系统里啦~如果没有,就 DEB系: Debian, Ubuntu, Deepin, Linux Mint以及各种衍生版本,包括Kali Linux和Parrot Sec Linux $ sudo apt-get install git RedHat系: Fedora, RHEL, CentOS $ sudo dnf install git emmm如果是CentOS这种万年不更新的系统的话,用yum就好啦: $ sudo yum install git Open SUSE: 没办法,SUSE自成一派,不过 YasT 确实好用,笔者电脑上就是Windows 10 + Open SUSE $ sudo zypper install git Arch系:Arch Linux, Manjaro, Gentoo $ sudo pacman -S git 我猜装个git不需要用AUR吧😨 (别问笔者为啥各大Linux的安装包管理器背的这么熟练,说出来都是泪) ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:2:1","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"Node.js 好了,Git 装完了,接下来装Hexo(我们的主角)的必备依赖! 他就是Node.js!(反正笔者也没学过,感觉很厉害就是了) Node.js下载地址 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:2:2","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"GitHub账号配置 接下来我们得注册一个GitHub 账号…… 喂,这么重要的东西,应该早就有了吧(手动滑稽 咳 注册完后,我们继续…… 现在我们来配置一下Git (什么?Hexo还没装呢?就先配置Git? ) Windows用户: 装好Git后,会有一个叫做Git Bash的东东出现在你的桌面上 ( Linux用户:不存在的 ) 然后…… 你可以找个清闲的地方 ( 不是叫你喝茶 ) ,新建一个文件夹,取一个喜欢的名字. ( 喂,不是给女儿起名字,那么认真干嘛 ) 然后右键,选择Git Bash Here. Linux用户: $ mkdir ./MyBlog ##你喜欢就好 $ cd ./MyBlog ##进入这个目录 然后,现在我们就可以把Windows和Linux统一起来说啦. 先配置一下你刚注册的账户~ $ git config --global user.name \"你的GitHub用户名\" $ git config --global user.email \"你的GitHub注册邮箱\" ( 啥? 没有一个叫 你的GitHub用户名 的用户? 不至于吧,我说的是你的GitHub的用户名,不是叫\"你的GitHub用户名\"的用户😓) 我们为了避免每次使用都要输入密码登录,可以配置一个叫SSH Key的东西: $ ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" ( 你不至于连open-ssh都没有吧……那得是一个多么精简的系统 ) 接下来会让你输入各种信息,啥都不输,无脑回车就行了. 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制. 再然后…… ( 我为哈说啥都要带个然后 ) 打开GitHub_Settings_keys 页面，新建new SSH Key 为了保证访问速度……我就不在博客上添加图片了哈,不然GitHub该生气了(手动滑稽 Title随便写,想写啥写啥,然后把刚刚复制的id_rsa.pub的内容粘贴到下面的Key里面,点击 Add SSH key,就OK啦! 然后我们回到Bash ( Linux用户别抬杠, 是个shell都可以, 笔者用的是zsh ) $ ssh git@github.com 如果出现了 Hi XXXX! You’ve successfully……balabala……就说明配置成功啦! 具体原理如下: 引自知乎 吴润的文章 这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:2:3","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"正式开始 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:0","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"安装HEXO 当当当! 我们的主角HEXO要登场啦! $ npm install -g hexo-cli 在我们的Git Bash里使用这条指令来安装hexo!安装会 比较 狠 慢! 因为……我们有伟大的万里长城防火墙啊…… ( 逃 ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:1","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"初始化博客 安装好之后,检查一下你当前的路径是不是刚刚让你找的清闲之地——一个你想把博客布置起来的空文件夹. 怎么检查? $ pwd 然后看输出的路径是不是 xxx/MyBlog 或者其他你取的名字. 确认完毕后,输入: $ hexo init 开始初始化你的博客吧! 然后一屏令人目眩的代码飞过…… 我们现在打开你的博客文件夹,就能看见下面多出了很多文件啦! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:2","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"本地预览博客 输入: $ hexo g $ hexo s 然后在浏览器点开 本地博客 就能看见我们的博客啦! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:3","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"HEXO的正确使用姿势 现在我们瞅一眼 hexo 的正确使用姿势: $ npm install hexo -g #安装Hexo $ npm update hexo -g #升级 $ hexo init #初始化博客 命令简写: $ hexo n \"文章名称\" == hexo new \"文章名称\" #新建文章,注意,\"\"里面是你的文章名称,不是 文章名称 ...... $ hexo g == hexo generate #生成本地文件 $ hexo s == hexo server #启动服务预览 $ hexo d == hexo deploy #部署到远程服务器 $ hexo server #Hexo会监视文件变动并自动更新，无须重启服务器 $ hexo server -s #静态模式 $ hexo server -p 5000 #更改端口 $ hexo server -i 192.168.1.1 #自定义 IP $ hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 就这样, 我们就可以掌握 hexo 的用法啦! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:4","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"发布到GitHub 看我们刚搭好的博客, 是不是有些激动? 什么? 嫌丑? 那不是现在要操心的事情……应当操心的是,如何才能发布到网站上? 这个时候,GitHub就要大显神威了. 打开你的GitHub页面, 然后新建一个仓库……仓库取名叫 你的用户名.github.io 我也不知道为啥非要写用户名,但是不写用户名后面的配置会出各种各样的奇怪问题…… 然后创建就可以啦. 然后! 用Visual Studio Code / Vim / Emacs / Sublime / Atom / Kate / Notepad …… ( 是个编辑器都行 ) 打开位于博客文件夹下的_config.yml, 然后把光标扯到最下面, 看到尾端有一个deploy的东东,编辑一下: ## Deployment ### Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git branch: master 回到Bash, 输入下面的指令安装部署插件: $ npm install hexo-deployer-git --save 然后! 我们就可以很方便的部署网站啦! 两条指令搞定! $ hexo clean #清除上次的缓存 $ hexo g -d #等价于执行hexo g 后再执行一次 hexo d , 这两个指令已经介绍过了. 打开 你的用户名.github.io,你的网站就已经部署好啦! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:3:5","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"日常使用 那我们怎么写博客呢? 只要打开Git Bash, cd到你的博客文件夹 ( Windows用户可以点开博客文件夹,右键 Git Bash Here)然后输入: $ hexo new post \"文章名称\" 就能新建一篇文章啦! 你可以去下载一个 Typora ,一款很好用的MarkDown编辑器–—–好用到你根本不会觉得你在写一个叫做MarkDown的标记语言…….事实上, 笔者现在仍旧对MarkDown保持着一股生疏感.安装好Typora之后,你可以打开设置,然后就可以设置每次打开的文件夹啦! 我们把文件夹设置为: MyBlog\\source\\_posts 以后写的文章就可以保存在这里啦! 想更新到GitHub的话,就是: $ hexo clean $ hexo g -d 然后打开你的博客地址 : 你的用户名.github.io就可以看见你刚写的文章啦! PS: 由于GitHub Pages需要每次重建,所以你可能不会很快的看见自己的文章咯~这样的话最好等上两分钟,你的文章就会出现在博客列表里啦! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:4:0","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Development"],"content":"未完待续~ 下集预告:安装Next主题, 配置我的博客! ","date":"2019-08-18","objectID":"/posts/construct_blog_with_hexo/:5:0","tags":["Web","Development"],"title":"使用GitHub和HEXO的博客搭建过程","uri":"/posts/construct_blog_with_hexo/"},{"categories":["Life"],"content":"前言 这是网上流行的一本绝版书籍,短短几页却浓缩了很多精华. 即使过了30余年, 其中的思想仍旧在编程时十分有参考价值. 时间挡不住作者的真知灼见. ","date":"2019-08-18","objectID":"/posts/the_elementary_of_programming_style/:1:0","tags":["Life","Learning"],"title":"The Elementary Of Programming Style","uri":"/posts/the_elementary_of_programming_style/"},{"categories":["Life"],"content":"正文 把代码写清楚，别耍小聪明。 想干什么，讲的简单点、直接点。 只要有可能，使用库函数。 避免使用太多的临时变量。 “效率”不是牺牲清晰性的理由。 让机器去干那些脏活。 重复的表达式应该换成函数调用。 加上括号、避免歧义。 不要使用含糊不清的变量名。 把不必要的分支去掉。 使用语言的好特性，不要使用那些糟糕的特性。 该用逻辑表达式的时候，不要使用过多的条件分支。 如果逻辑表达式不好理解，就试着做下变形。 选择让程序更简洁的数据表达形式。 先用伪代码写，再翻译成你使用的语言。 模块化。使用过程和函数。 只要你能保证程序的可读性，能不用 goto 就别用 。 不要给糟糕的代码打补丁 - 重写就是了。 把大的程序分成一小片一小片来写，分块测试。 使用递归程序来处理递归定义的数据结构。 正确和错误的输入数据都要测试。 确保输入不会超出程序的限制。 依靠文件结束来终止输入，而不是依赖一个记数。 把文件结束作为一个输入状态来处理。 识别出错误的输入；如果有可能就修复它。 让输入数据很容易构造出来，让输出数据不言自明。 使用统一的输入格式。 让输入容易校对。 如有可能，提供更自由的输入格式。 使用输入提示，允许使用默认值。并把它们显示出来。 把输入输出放到子程序里。 确保所有的变量在使用前都有初始化。 不要因为一个 bug 而停止不前。 打开编译程序的调试选项。 常量结构用数据声明初始化，变量结构用执行代码初始化。 小心 off-by-one 错误。 当循环中有多个跳出点时要小心。 如果什么都不做，那么也要优雅的表现出这个意思。 用边界值测试程序。 手工检查一些答案。 防御式编程 - 为不可能的情况写几句代码。 10.0 乘 0.1 很难保证永远是 1.0 。 7/8 等于 0 ，而 7.0/8.0 不等于 0 。 不要直接判断两个浮点数相等。 先做对，再弄快。 先使其可靠，再让其更快。 先把代码弄干净，再让它变快。 别为了获得一丁点“性能”就牺牲掉整洁。 让编译器做些简单的优化。 不要过分追求重用代码；下次用的时候重新组织一下即可。 确保特殊的情况是真的特殊。 保持简洁以获得速度。 不要死磕代码来加快速度 - 找个更好的算法。 用工具分析你的程序。在做“性能”改进前先评测一下。 确保注释和代码一致。 不要在注释里仅仅重复代码 - 让每处注释都有价值。 不要给糟糕的代码做注释 - 应该重写它。 给变量都起个有意义的名字。 把程序重新整理一下，让阅读代码的人更容易理解。 为你的数据布局写一个文档。 不要过分注释。 ","date":"2019-08-18","objectID":"/posts/the_elementary_of_programming_style/:2:0","tags":["Life","Learning"],"title":"The Elementary Of Programming Style","uri":"/posts/the_elementary_of_programming_style/"},{"categories":["Life"],"content":"我的第一篇博文!! ","date":"2019-08-16","objectID":"/posts/hello_world/:0:0","tags":["Life"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["Life"],"content":"开始 应该写些什么好呢？ 这是一个问题。 从我有这个建站的想法开始，到博客投入使用，前后不过一个晚上加一个上午的时间。 不得不说，自我感觉进度还是很快的。 在阿里云买的域名，然后通过GitHub Pages发布，配合上Hexo博客的简单配置，自我感觉非常良好。 ","date":"2019-08-16","objectID":"/posts/hello_world/:1:0","tags":["Life"],"title":"Hello World","uri":"/posts/hello_world/"},{"categories":["Life"],"content":"接下来做什么 我应该会在接下来的一个星期里面完善整个博客的搭建过程，顺便为本博客多加几篇博文。 ","date":"2019-08-16","objectID":"/posts/hello_world/:2:0","tags":["Life"],"title":"Hello World","uri":"/posts/hello_world/"}]